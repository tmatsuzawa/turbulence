#!/usr/bin/env python
"""
Currently, it can only calculate circulation when vorticity data is output by PIVLab.
I should implement a feature to calculate vorticity out of velocity field data in the future. - Takumi 02/12/2018
"""
import argparse
import os
import time
import sys

import cine
import json
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import pickle
from matplotlib import cm
from scipy import ndimage, interpolate
from mpl_toolkits.axes_grid1 import make_axes_locatable
from scipy import ndimage
#import ilpm.cine as cine
import numpy as np

sys.path.append('/Users/stephane/Documents/git/takumi/')
import library.tools.process_data as process

cmap = cm.spectral
cmap2 = cm.bwr

cx_lim = 100
cy_lim = 100

threshold = .08

#cutoff values for cleaning raw data
cutoffu = 2.
cutoffomega = 0.1

# new grid spacing in px
__xint__, __yint__ = 1., 1.

#Output directory
OUTDIR = '/Volumes/labshared3-1/takumi/2018_02_01/PIV_AnalysisResults/'

def load_matlab_data(datapath):
    """Reads data from .txt files generated by PIVlab and places them into numpy arrays

    Parameters
    ----------
    data_loc : str
        The directory containing .txt files generated from PIVlab

    Returns
    -------
    x, y, ux, uy, omega array (floats)
        coordinates, velocity components, and vorticity calculated by PIVlab in easy to use numpy array format
    """
    file = open(datapath)
    x, y, ux, uy, omega = [], [], [], [], []
    for i, line in enumerate(file):
        if i < 3:
            continue
        for j, val in enumerate(line.split(',')):
            if j == 0:
                x.append(int(val))
            elif j == 1:
                y.append(int(val))
            elif j == 2:
                ux.append(float(val))
            elif j == 3:
                uy.append(float(val))  # Note that there is a minus sign due to the default coordinate system in PIVLab.
            elif j == 4:
                omega.append(float(val))

    if j==4:
        x, y, ux, uy, omega = map(lambda z: np.asarray(z), [x, y, ux, uy, omega])
        return x, y, ux, uy, omega
    elif j==3:
        x, y, ux, uy = map(lambda z: np.asarray(z), [x, y, ux, uy])
        return x, y, ux, uy


def interp_flow_component(x, y, ux, xint=__xint__, yint=__yint__, method='linear'):
    uxindicies = [(xx, yy) for xx, yy in zip(x, y)]
    #grid_ind0, grid_ind1 = mgrid[0:imsize[0], 0:imsize[1]]
    #griddata = interpolate.griddata(uxindicies, ux, (grid_ind0, grid_ind1), method=method, fill_value=0.)
    xmin, xmax, ymin, ymax = np.min(x), np.max(x), np.min(y), np.max(y)
    xnew, ynew = np.arange(xmin, xmax + xint, xint), np.arange(ymin, ymax + yint, yint)
    Xnew, Ynew = np.meshgrid(xnew, ynew)
    griddata = interpolate.griddata(uxindicies, ux, (Xnew, Ynew), method=method, fill_value=0.)

    return Xnew, Ynew, griddata

def interp_for_pcolormesh(x, y, data, xint=__xint__, yint=__yint__, method='cubic'):
    """
    (PIVLab only)
    Takes 1d arrays for x, y, data, and generate a grid, interpolate data, 
    and give back grids (2d arrays generated by np.meshgrid) and interpolated data
    One can immediately generate a heatmap by using pcolormesh(Xnew, Ynew, datanew)
    
    Parameters
    ----------
    x 1d array
    y 1d array 
    data 1d array
    xint interval of new x, float
    yint interval of new x, float
    method method of interpolation, str
           Refer to interpolate.interp2d for available options

    Returns
    -------
    Xnew 2d array generated by np.meshgrid
    Ynew 2d array generated by np.meshgrid
    datanew 2d array
    
    """
    f = interpolate.interp2d(x, y, data, kind=method)

    # make a meshgrid
    xnew, ynew = np.arange(x[0], x[-1] + xint, xint), np.arange(y[0], y[-1] + yint, yint)
    Xnew, Ynew = np.meshgrid(xnew, ynew)
    # interpolate using scipy.interpolate.inter2d
    datanew = f(xnew, ynew)

    return Xnew, Ynew, datanew


def colorbar(mappable, location='right'):

    ax = mappable.axes
    fig = ax.figure
    divider = make_axes_locatable(ax)
    cax = divider.append_axes(location, size='5%', pad=0.05)
    return fig.colorbar(mappable, cax=cax)


def weighted_mean(means, stds):
    """
    Compute weighted arithmetic mean
    Parameters
    ----------
    means : list (floats)
        list of mean values
    stds : list (floats)
        list of standard deviations associated to means

    Returns
    -------
    weighted_mean : float
    """
    return sum(np.asarray(means * (1. / np.asarray(stds)))) / sum(1. / np.asarray(stds))


def weighted_mean_std(stds):
    """
    Compute the uncertainty for a weighted mean
    Parameters
    ----------
    stds : list (floats)
        list of standard deviations associated to means

    Returns
    -------
    weighted_mean_std : float
    """
    return np.sqrt(1. / sum(1. / np.asarray(stds)))


def find_center_of_arr2d(arr):
    arr = np.array(arr)
    cx, cy =0, 0
    for i in range(arr.shape[0]):
        for j in range(arr.shape[1]):
                cx = i * arr[i][j]
                cy = j * arr[i][j]
    cx, cy = cx / arr.sum(), cy / arr.sum()
    return cx, cy






if __name__ == '__main__':
    """
    Pass a absolute path of the cine files through '-input' e.g. -input '/absolute/path/to/cineDir/*.cine'
    """
    parser = argparse.ArgumentParser(description='')
    parser.add_argument('-input', metavar='input', type=str, nargs='*', default=None, help='')
    parser.add_argument('-NP', dest='NP', type=int, default=800,
                        help='Number of points to sample along the circulation contour')
    parser.add_argument('-min_radius', dest='min_radius', type=float, default=10,
                        help='Smallest radius of circulation contour explored (p)')
    parser.add_argument('-max_radius', dest='max_radius', type=float, default=70,
                        help='Largest radius of circulation contour explored (px)')
    parser.add_argument('-sample_pts', dest='sample_pts', type=int, default=10,
                        help='number of points between min and max radius at which to sample the circulation')
    parser.add_argument('-cm_shift', dest='cm_shift', type=int, default=10,
                        help='Largest amount to shift the center of the circulation contour (px)')  #in px

    parser.add_argument('-scale', dest='scale', type=float, default=None)
    parser.add_argument('-rate', dest='rate', type=float, default=None)
    parser.add_argument('-frame_spacing', dest='frame_spacing', type=float, default=1)
    parser.add_argument('-plot_spacing', dest='plot_spacing', type=int, default=1)

    parser.add_argument('-start', dest='start', type=int, default=0)
    parser.add_argument('-stop', dest='stop', type=int, default=0)
    parser.add_argument('-skip', dest='skip', type=int, default=10)

    parser.add_argument('-omegabool', dest='omegabool', default=True)


    parser.add_argument('--summarize', dest='summarize', action='store_true', default=False,
                        help='Plot only the aggregate data, assuming that the .json files have already been generated')
    parser.add_argument('--save_circ', dest='save_circ', action='store_true', default=False)


    # PARSE COMMAND LINE INPUTS
    args = parser.parse_args()

    cine_inputs = args.input
    NP = args.NP
    min_radius = args.min_radius
    max_radius = args.max_radius
    sample_pts = args.sample_pts
    cm_shift = args.cm_shift # in mm (NOT px)
    summarize = args.summarize
    save_circ = args.save_circ
    scale = args.scale
    rate = args.rate
    frame_spacing = args.frame_spacing
    plot_spacing = args.plot_spacing
    omegabool = args.omegabool

    # SETUP SOME VARIABLES FOR PLOTTING TO BE USED THROUGHOUT SCRIPT
    radii = np.linspace(min_radius*scale, max_radius*scale, num=sample_pts, endpoint=True)
    radii_diff = (max_radius*scale - min_radius*scale)/float(sample_pts-1)
    phi = np.arange(NP) * 2 * np.pi / float(NP)

    import numpy as np

    import matplotlib

    matplotlib.use('Agg')
    import matplotlib.pyplot as mpl

    from scipy.interpolate import interp1d
    from scipy.ndimage import map_coordinates

    for cnum, cine_file in enumerate(cine_inputs):

        # LOAD CINE FILE AND GRAB IMAGE SIZE

        movie = cine.open(cine_file)
        imsize = np.shape(movie[0])

        box_size = 32

        # GENERATE FILE ARCHITECTURE
        date_dir, cine_name = os.path.split(cine_file)
        name, ext = os.path.splitext(cine_name)
        #cine_dir = os.path.join(date_dir, name)
        resultsdir = date_dir + '/PIV_AnalysisResults/' + name #ABS PATH TO OUTPUT DIRECTORY
        #resultsdir = '/Users/stephane/Documents/Takumi/Analysis_Results/' + name
        #resultsdir = OUTDIR + name

        print 'Working on Cine file: ', name

        # # CREATE A DIRECTORY TO STORE RESULTS
        # if not os.path.exists(resultsdir):
        #     os.makedirs(resultsdir)

        # CREATE A DIRECTORY TO STORE RESULTS OF CIRCULATION COMPUTATION
        circulation_dir = resultsdir + '/circulation/'
        if not os.path.exists(circulation_dir):
            os.makedirs(circulation_dir)

        # GRAB A DIRECTORY NAME WHERE PIVLAB-GENERATED txt FILES ARE STORED
        data_dir = date_dir + '/PIV_W%s_step%s_data' % (box_size, int(frame_spacing)) + \
                   '/PIVlab_ratio2_W%spix_Dt_%s_' % (box_size, int(frame_spacing)) + name

        print movie.len


        # CHECK IF DATA FILES(txt FILES GENERATED BY PIVLAB) EXIST
        if not os.path.exists(data_dir):
            print 'NO DATA DIRECTORY FOUND! EXITING'
            sys.exit()


        # INITIALIZE EMTPY LISTS FOR ROBUST GAMMA COMPUTATIONS
        robust_gammas = []
        robust_radii = []
        robust_frames = []
        robust_wav_gammas = []
        robust_wav_stds = []

        # ITERATE THROUGH FRAMES IN CINE FILE
        if args.stop == 0:
            frames = range(args.start, movie.__len__(), args.skip)
        else:
            frames = range(args.start, args.stop, args.skip)
        print 'Working on frame range: (%d:%d)' % (frames[0], frames[-1])

        for i, f in enumerate(frames):
            print 'image size: ', imsize
            if f - ((f/plot_spacing) * plot_spacing) == 0:
                print 'Processing frame %d' % f
                try:
                    i += frames[0] / frame_spacing
                except TypeError:
                    print 'NO FRAME SPACING SPECIFIED! EXITING'

                # Read data from txt files generated by PIVLab
                print data_dir
                if os.path.exists(os.path.join(data_dir, 'D%04d.txt' % f)):
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, 'D%04d.txt' % f))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, 'D%04d.txt' % f))
                    print 'Loaded D%04d.txt' % f
                elif os.path.exists(os.path.join(data_dir, 'D%03d.txt' % f)):
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, 'D%03d.txt' % f))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, 'D%03d.txt' % f))
                    print 'Loaded D%03d.txt' % f
                elif os.path.exists(os.path.join(data_dir, 'D%02d.txt' % f)):
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, 'D%02d.txt' % f))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, 'D%02d.txt' % f))
                    print 'Loaded D%02d.txt' % f
                elif os.path.exists(os.path.join(data_dir, 'D%01d.txt' % f)):
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, 'D%01d.txt' % f))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, 'D%01d.txt' % f))
                    print 'Loaded D%01d.txt' % f
                else:
                    print 'NO DATA EXISTS FOR FRAME: %d; SKIPPING!' % f


                # Clean data by excluding unreasonable values and linearly interpolating excluded data points
                print 'Cleaning ux... cutoff is ' + str(cutoffu * scale * rate) + 'mm/s'
                ux = process.clean_multi_dim_array(ux, cutoff=cutoffu, verbose=False)
                print 'Cleaning uy... cutoff is ' + str(cutoffu * scale * rate) + 'mm/s'
                uy = process.clean_multi_dim_array(uy, cutoff=cutoffu, verbose=False)
                print 'Cleaning omega... cutoff is ' + str(cutoffomega * rate) + '1/s'
                omega = process.clean_multi_dim_array(omega, cutoff=cutoffomega, verbose=False)




                # Figure out the number of voxels (nx, ny)
                nx, ny = (x[-1]-x[0])*2/box_size + 1, (y[-1]-y[0])*2/box_size + 1
                # Prepare a grid
                #Xgrid, Ygrid = np.mgrid[slice(x[0], x[-1]+1, box_size/2), slice(y[0], y[-1]+1, box_size/2)]

                # Reshape omega into nx x ny array
                xgrid = np.array(x).reshape((nx, ny))
                ygrid = np.array(y).reshape((nx, ny))
                omegagrid = np.array(omega).reshape((nx, ny))
                uxgrid = np.array(ux).reshape((nx, ny))
                uygrid = np.array(uy).reshape((nx, ny))


                # COMPUTE INTERPOLATED VELOCITY AND VORTICITY
                # CONVERT PX -> MM AND FRAME -> SEC
                Xgrid, Ygrid, iuxgrid = interp_flow_component(x*scale, y*scale, ux * scale * rate)
                Xgrid, Ygrid, iuygrid = interp_flow_component(x*scale, y*scale, uy * scale * rate)
                Xgrid, Ygrid, iomegagrid = interp_flow_component(x*scale, y*scale, omega * rate)

                xmin, xmax, ymin, ymax = min(Xgrid.flatten()), max(Xgrid.flatten()), min(Ygrid.flatten()), max(Ygrid.flatten())
                print 'Window dimension: ', (xmin, xmax, ymin, ymax)



                # FIND THE CENTER OF VORTICES  (keep track of negative z)
                ## Simplest approach is to find a position of the maximum or minumum of vorticity
                # # Keep track of a vortex of positive vorticity
                # cx, cy = Xgrid[max_x, max_y], max(Ygrid.flatten()) - Ygrid[max_x, max_y]
                # Keep track of a vortex of negative vorticity
                #cx, cy = Xgrid[min_x, min_y], max(Ygrid.flatten()) - Ygrid[min_x, min_y]

                # #Method 1: extrema of  vorticity
                # max_x, max_y = where(iomegagrid == max(iomegagrid.flatten()))
                # min_x, min_y = where(iomegagrid == min(iomegagrid.flatten()))
                # print 'Center of vortices- Method 1: ', max_x, max_y
                #cx, cy = Xgrid[min_x, min_y], max(Ygrid.flatten()) - Ygrid[min_x, min_y]

                #Method 2: extrema of vorticity (ignore the edges)]
                # nxedges = int(np.abs((xgrid[1][0] - xgrid[0][0]))/__xint__)
                # nyedges = int(np.abs((ygrid[0][1] - ygrid[0][0]))/__yint__)
                # print nxedges, nyedges
                # iomegagrid_no_edges = iomegagrid[nxedges:-nxedges, nyedges:-nyedges]
                # max_x, max_y = where(iomegagrid == max(iomegagrid_no_edges.flatten()))
                # min_x, min_y = where(iomegagrid == min(iomegagrid_no_edges.flatten()))
                # print 'Center of vortices- Method 2: ', max_x, max_y
                # cx, cy = Xgrid[min_x, min_y], max(Ygrid.flatten()) - Ygrid[min_x, min_y]

                # Method 3: weighted center of vorticity (ignore the edges)]
                nxedges = int(np.abs((xgrid[1][0] - xgrid[0][0]))/__xint__)
                nyedges = int(np.abs((ygrid[0][1] - ygrid[0][0]))/__yint__)
                print 'iomegagrid.shape: ', iomegagrid.shape
                print 'Number of points ignored from the horizontal and vertical edges: ', nxedges, nyedges

                # Exclude vorticity data at the edges
                iomegagrid_no_edges = iomegagrid[nxedges:-nxedges, nyedges:-nyedges]
                # Find the maximum/minimum value of vorticity in the field
                iomegamax = max(iomegagrid_no_edges.flatten())
                iomegamin = min(iomegagrid_no_edges.flatten())
                # Find a position of maximum/minimum vorticity
                max_x, max_y = np.where(iomegagrid == iomegamax)
                min_x, min_y = np.where(iomegagrid == iomegamin)
                print 'Vortex ring core positions(maximum/minumum omega):',\
                    (Xgrid[int(max_x), int(max_y)], Ygrid[int(max_x), int(max_y)]), (Xgrid[int(min_x), int(min_y)], Ygrid[int(min_x), int(min_y)])
                #Extract a fraction of vorticity data around a posion of maximum/minimum vorticity
                nx_frac, ny_frac = int(nxedges/2.), int(nyedges/2.)
                iomegagrid_around_max = iomegagrid[int(max_x - nx_frac):int(max_x + nx_frac + 1), int(max_y - ny_frac):int(max_y + ny_frac + 1)]
                iomegagrid_around_min = iomegagrid[int(min_x-nx_frac):int(min_x+nx_frac+1), int(min_y-ny_frac):int(min_y+ny_frac+1)]
                Xgrid_around_max = Xgrid[int(max_x-nx_frac):int(max_x+nx_frac+1), int(max_y-ny_frac):int(max_y+ny_frac+1)]
                Ygrid_around_max = Ygrid[int(max_x-nx_frac):int(max_x+nx_frac+1), int(max_y-ny_frac):int(max_y+ny_frac+1)]
                Xgrid_around_min = Xgrid[int(min_x-nx_frac):int(min_x+nx_frac+1), int(min_y-ny_frac):int(min_y+ny_frac+1)]
                Ygrid_around_min = Ygrid[int(min_x-nx_frac):int(min_x+nx_frac+1), int(min_y-ny_frac):int(min_y+ny_frac+1)]
                # Find ring core positions weighted by normalized vorticity
                max_xw, max_yw = ndimage.measurements.center_of_mass(iomegagrid_around_max)
                max_xw, max_yw = int(np.around(max_xw)), int(np.around(max_yw))
                min_xw, min_yw = ndimage.measurements.center_of_mass(iomegagrid_around_min)
                min_xw, min_yw = int(np.around(min_xw)), int(np.around(min_yw))
                # print 'ndimage.measurements.center_of_mass', min_xw, min_yw


                try:
                    # Track a position of vortex ring core of positive vorticity
                    cx, cy = Xgrid_around_max[max_xw, max_yw], Ygrid_around_max[max_xw, max_yw]   #in mm (NOT px)
                    ## Track a position of vortex ring core of negative vorticity
                    #cx, cy = Xgrid_around_min[min_xw, min_yw], Ygrid_around_min[min_xw, min_yw]
                    print 'Vortex ring core positions(Weighted by normalized vorticity): ', \
                        (Xgrid_around_max[max_xw, max_yw], Ygrid_around_max[max_xw, max_yw]), \
                        (Xgrid_around_min[min_xw, min_yw], Ygrid_around_min[min_xw, min_yw])
                except IndexError:
                    print 'Tracking vortex ring core is too close to the the edge. SKIPPING...'
                    continue


                # CONFIRM THAT CIRCULATION CURVES ARE ALL IN THE FRAME
                print 'Minimum/Maximum radius:', (radii.min(), radii.max())
                bad_x_path = False
                path_x_limits = radii[-1] * np.cos(phi) + cx  #in mm
                bad_y_path = False
                path_y_limits = radii[-1] * np.sin(phi) + cy  #in mm
                cutoff = ((box_size / 2) + 1 ) * scale # in mm
                #print imsize[0], imsize[1]
                if (path_y_limits <= cutoff).any() or (path_y_limits >= (imsize[1] - cutoff)).any():
                    bad_y_path = True
                if (path_x_limits <= cutoff).any() or (path_x_limits >= (imsize[0] - cutoff)).any():
                    bad_x_path = True
                #print bad_x_path, bad_y_path
                if bad_x_path or bad_y_path:
                    print 'CIRCULATION CURVE NOT IN FRAME, SKIPPING'
                    continue


                # SET BOUNDS FOR COLOR BARS
                w_limit = cutoffomega * rate /1.2
                ux_limit = cutoffu * scale * rate /1.2
                uy_limit = cutoffu * scale * rate /1.2



                #Plot
                #Method1-3 has issues with the axes. Data should be rotated by 180, and -90 deg.
                #I should fix this in the near future. - Takumi 2/9/18
                # xphys = x * scale
                # yphys = y * scale
                # #Method 1: pcolormesh
                # ## interpolation may be trickier than imshow
                # w_limit = maximum(max(omega.flatten()), abs(min(omega.flatten())))
                # graph.color_plot(xphys, yphys, omegagrid * rate, vmin=-w_limit, vmax=w_limit, cmap=cmap,fignum=1)
                # graph.colorbar()
                # graph.title('pcolormesh- no interpolation', fignum=1)
                #
                #
                # ##Method 2 pcolormesh + interpolation (use x4 more data points)
                # # interpolate data using scipy.interpolate.interp2d()
                # Xnew, Ynew, omeganew = interp_for_pcolormesh(x, y, omega * rate, xint=16., yint=16.)
                # w_limit = 400
                # graph.color_plot(Xnew, Ynew, omeganew, vmin=-w_limit, vmax=w_limit, cmap=cmap, fignum=2)
                # graph.colorbar(fignum=2)
                # graph.title('pcolormesh- linear interpolation', fignum=2)
                #
                # #Method 3:imshow (raw data)
                ## Various interpolation methods are available
                # graph.imshow(iomegagrid, xmin=x.min(), xmax=x.max(), ymin=y.min(), ymax=y.max(), interpolation='gaussian',\
                #              cmap=cmap,vmin=-w_limit,vmax=w_limit, fignum=3)
                # graph.title('imshow (raw data)' , fignum=3)

                #Method 4: imshow + interpolation on griddata using interpolate.griddata
                # fig, ax, cax, cc = graph.imshow(iomegagrid, xmin=x.min(), xmax=x.max(), ymin=y.min(), ymax=y.max(), interpolation='gaussian',\
                #              cmap=cmap,vmin=-w_limit,vmax=w_limit, fignum=4, cbar=True)
                # graph.title('imshow + interpolation- gaussian', fignum=4)
                # cc.set_label('$\omega_z [1/s]$')


                fig = plt.figure(figsize=(18, 14))
                gs = gridspec.GridSpec(3, 3, width_ratios=[1, 1, 1], height_ratios=[1.5, 1, 2])
                img1 = fig.add_subplot(gs[0])
                for r in radii:
                    img1.plot(r * np.cos(phi) + cx, r * np.sin(phi) + cy, color=cmap(float(r) / float(max(radii))))
                ax1 = img1.imshow(iuxgrid, cmap=cmap2, vmin=-ux_limit, vmax=ux_limit, interpolation='gaussian',\
                        extent = (xmin, xmax, ymax, ymin))
                img1.set_xlabel('X $[mm]$')
                img1.set_ylabel('Y $[mm]$')
                colorbar(ax1)

                # iUy Plot
                img2 = fig.add_subplot(gs[1])
                for r in radii:
                    img2.plot(r * np.cos(phi) + cx, r * np.sin(phi) + cy, color=cmap(float(r) / float(max(radii))))
                ax2 = img2.imshow(iuygrid, cmap=cmap2, vmin=-uy_limit, vmax=uy_limit, interpolation='gaussian',\
                        extent = (xmin, xmax, ymax, ymin))
                img2.set_xlabel('X $[mm]$')
                img2.set_ylabel('Y $[mm]$')
                colorbar(ax2)


                # iOmega Plot
                img3 = fig.add_subplot(gs[2])
                for r in radii:
                    img3.plot(r * np.cos(phi) + cx, r * np.sin(phi) + cy, color=cmap(float(r) / float(max(radii))))
                ax3 = img3.imshow(iomegagrid, cmap=cmap2, vmin=-w_limit, vmax=w_limit, interpolation='gaussian',\
                        extent = (xmin, xmax, ymax, ymin))
                img3.set_xlabel('X $[mm]$')
                img3.set_ylabel('Y $[mm]$')
                colorbar(ax3)


                imgs = [img1, img2, img3]
                titles = ['$u_x$ velocity $(mm/s)$', '$u_y$ velocity $(mm/s)$', '$\omega_z$ $(1/s)$']
                for img, text in zip(imgs, titles):
                    #img.set_xlim([x[0], imsize[1] - x[0]])
                    #img.set_ylim([y[0], imsize[0] - y[0]])
                    #img.set_xticks([])
                    #img.set_yticks([])
                    img.set_title(text)

                    ax4 = plt.subplot(gs[3])
                    ax5 = plt.subplot(gs[4])
                    ax6 = plt.subplot(gs[5])
                    ax4.set_ylabel('velocity $(mm/s)$')

                mean_gs = []
                std_gs = []
                for r in radii:
                    path_x, path_y = r * np.cos(phi) + cx, r * np.sin(phi) + cy
                    iux_p = ndimage.map_coordinates(iuxgrid, (path_y, path_x), order=1)
                    iuy_p = ndimage.map_coordinates(iuygrid, (path_y, path_x), order=1)

                    ax4.plot(phi, iux_p, color=cmap(float(r) / float(max(radii))))
                    ax5.plot(phi, iuy_p, color=cmap(float(r) / float(max(radii))))
                    ax6.plot(phi, -iux_p * np.sin(phi) + iuy_p * np.cos(phi), color=cmap(float(r) / float(max(radii))))

                    # CALCULATE AND PLOT CIRCULATIONS AND STATISTICS
                    gammas = []
                    ax7 = plt.subplot(gs[6:])
                    cm_shift_list = np.linspace(-cm_shift*scale, cm_shift*scale, num=10)
                    for off_i in cm_shift_list:
                        for off_j in cm_shift_list:
                            ds = 2 * np.pi * r / float(NP)
                            path_x, path_y = r * np.cos(phi) + cx + off_i, r * np.sin(phi) + cy + off_j
                            iux_p = ndimage.map_coordinates(iuxgrid, (path_y, path_x), order=1)
                            iuy_p = ndimage.map_coordinates(iuygrid, (path_y, path_x), order=1)
                            gammas.append(sum((-iux_p * np.sin(phi) + iuy_p * np.cos(phi)) * ds))

                    mean_g = np.mean(np.asarray(gammas))
                    mean_gs.append(mean_g)
                    std_g = np.std(np.asarray(gammas))
                    std_gs.append(std_g)

                    ax7.scatter(r, mean_g, color=cmap(float(r) / float(max(radii))), marker='o')
                    ax7.errorbar(r, mean_g, yerr=std_g, ecolor=cmap(float(r) / float(max(radii))),
                                 elinewidth=2)


                    axes = [ax4, ax5, ax6]
                    titles = ['$u_x$', '$u_y$', r'$u_\theta$']
                    for ax, text in zip(axes, titles):
                        ax.set_title(text)
                        ax.set_xlim([0, 2 * np.pi])
                        ax.set_ylim([-ux_limit, ux_limit])
                        ax.set_xticks((0, np.pi, 2 * np.pi))
                        ax.set_xticklabels(('$0$', '$\pi$', '$2\pi$'))

                    # STORE ROBUST AND WEIGHTED AVERAGE CIRCULATION DATA
                    robust_g = mean_gs[np.argmin(np.asarray(std_gs))]
                    robust_r = radii[np.argmin(np.asarray(std_gs))]
                    weighted_avg = weighted_mean(mean_gs, std_gs)
                    weighted_avg_std = weighted_mean_std(std_gs)

                    #ax7.plot([radii[0], radii[-1]], [weighted_avg, weighted_avg], 'k--')
                    #ax7.plot([radii[0], radii[-1]], [robust_g, robust_g],
                    #         color=cmap(float(robust_r) / float(max(radii))))
                    #ax7.set_ylim([0, 30000])
                    ax7.set_xlabel('countour radius $(mm)$')
                    ax7.set_ylabel('circulation $(mm^2/s)$')
                    ax7.set_title('time: %.4f' % (f / rate))
                    ax7.set_xlim([0, np.max(radii)+radii_diff])



                    # STORE CIRCULATION DATA IN JSON FORMAT AND SAVE PLOT
                    circulation_data = {'mean_gamma': list(mean_gs),
                                        'std_gamma': list(std_gs),
                                        'radii': list(radii),
                                        'weighted_avg': weighted_avg,
                                        'weighted_avg_std': weighted_avg_std}

                print weighted_avg, weighted_avg.shape

                # Show results on plot
                gammaavg = np.mean(mean_gs[-5:])
                gammastd = np.mean(std_gs[-5:])
                gammaplusstd = [mean_gs[i] + std_gs[i] for i in range(len(mean_gs))]
                gammaminusstd = [mean_gs[i] - std_gs[i] for i in range(len(mean_gs))]
                gammadiff = np.abs(np.max(gammaplusstd)-np.min(gammaminusstd))
                textposystep = gammadiff/10.
                if np.min(gammaminusstd) > 0:
                    ax7.set_ylim([0, np.max(gammaplusstd)])
                else:
                    ax7.set_ylim([np.min(gammaminusstd), np.max(gammaplusstd)])
                text = 'highest $\Gamma_{avg}$: ' + str(np.max(mean_gs)) + ' $mm^2/s$'
                ax7.text(radii[-int(0.4*sample_pts)], textposystep * 3, text, fontsize=12)
                text='average of last 5 values: ' + str(gammaavg) + ' $mm^2/s$'
                ax7.text(radii[-int(0.4*sample_pts)], textposystep * 2, text, fontsize=12)
                text='average of last 5 std : ' + str(gammastd) + ' $mm^2/s$'
                ax7.text(radii[-int(0.4*sample_pts)], textposystep * 1, text, fontsize=12)



                #plt.show()

                # Save data in json format
                # circulation_data_name = 'circulation_data_%06d.json' % f
                # circulation_data_file = os.path.join(circulation_dir, circulation_data_name)
                # with open(circulation_data_file, 'w') as fyle:
                #     json.dump(circulation_data, fyle, sort_keys=True, indent=1, separators=(',', ': '))
                #     fyle.close()
                # Save a plot in png
                fig_name = 'circulation_%06d.png' % f
                fig_file = os.path.join(circulation_dir, fig_name)
                plt.savefig(fig_file)
                print 'Saved...' + fig_file
                plt.close()


    print 'Done'