#!/usr/bin/env python
"""
Computes and plots circulation at every args.plot_spacing frames
Computes and plots circulation velocity and radius of vortex rings over time
"""
import argparse
import os
import time
import sys

import cine
import json
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import pickle
from matplotlib import cm
from scipy import ndimage, interpolate
from mpl_toolkits.axes_grid1 import make_axes_locatable
from scipy import ndimage
# import ilpm.cine as cine
import numpy as np

import matplotlib
matplotlib.use('Agg')

from scipy.interpolate import interp1d
from scipy.ndimage import map_coordinates

import library.basics.formatarray as fa
import library.tools.browse as browse
import library.tools.process_data as process
import library.display.graph as graph
import library.basics.formatstring as fs
import library.basics.formatarray as fa

cmap = cm.spectral
cmap2 = cm.bwr

cx_lim = 100
cy_lim = 100

threshold = .08

# cutoff values for cleaning raw data
cutoffu = 2.  #px/frame
cutoffomega = 0.05 #/frame

# new grid spacing in px
__xint__, __yint__ = 1., 1.

# Frequencey of computing ring velocity
vrtimestep = 3  # compute vr every n steps
# Output directory
#OUTDIR = '/Volumes/labshared3-1/takumi/2018_02_01/PIV_AnalysisResults_spacing/'


def load_matlab_data(datapath):
    """Reads data from .txt files generated by PIVlab and places them into numpy arrays

    Parameters
    ----------
    data_loc : str
        The directory containing .txt files generated from PIVlab

    Returns
    -------
    x, y, ux, uy, omega array (floats)
        coordinates, velocity components, and vorticity calculated by PIVlab
    """
    file = open(datapath)
    x, y, ux, uy, omega = [], [], [], [], []
    for i, line in enumerate(file):
        if i < 3:
            continue
        for j, val in enumerate(line.split(',')):
            if j == 0:
                x.append(int(val))
            elif j == 1:
                y.append(int(val))
            elif j == 2:
                ux.append(float(val))
            elif j == 3:
                uy.append(float(val))  # Note that there is a minus sign due to the default coordinate system in PIVLab.
            elif j == 4:
                omega.append(float(val))

    if j == 4:
        x, y, ux, uy, omega = map(lambda z: np.asarray(z), [x, y, ux, uy, omega])
        return x, y, ux, uy, omega
    elif j == 3:
        x, y, ux, uy = map(lambda z: np.asarray(z), [x, y, ux, uy])
        return x, y, ux, uy

def interp_flow_component(x, y, ux, xint=__xint__, yint=__yint__, method='linear'):
    """
    Interpolate x,y, and data (ux) into x_new which has interval of __xint__
    Parameters
    ----------
    x
    y
    ux
    xint
    yint
    method

    Returns
    -------
    Xnew, Ynew: x and y coordinates of a grid
    datanew : 2d numpy array

    """
    uxindicies = [(xx, yy) for xx, yy in zip(x, y)]
    # grid_ind0, grid_ind1 = mgrid[0:imsize[0], 0:imsize[1]]
    # griddata = interpolate.griddata(uxindicies, ux, (grid_ind0, grid_ind1), method=method, fill_value=0.)
    xmin, xmax, ymin, ymax = np.min(x), np.max(x), np.min(y), np.max(y)
    xnew, ynew = np.arange(xmin, xmax + xint, xint), np.arange(ymin, ymax + yint, yint)
    Xnew, Ynew = np.meshgrid(xnew, ynew)
    griddata = interpolate.griddata(uxindicies, ux, (Xnew, Ynew), method=method, fill_value=0.)

    return Xnew, Ynew, griddata

def interp_for_pcolormesh(x, y, data, xint=__xint__, yint=__yint__, method='cubic'):
    """
    (PIVLab only)
    Takes 1d arrays for x, y, data, and generate a grid, interpolate data, 
    and give back grids (2d arrays generated by np.meshgrid) and interpolated data
    One can immediately generate a heatmap by using pcolormesh(Xnew, Ynew, datanew)

    Parameters
    ----------
    x 1d array
    y 1d array 
    data 1d array
    xint interval of new x, float
    yint interval of new x, float
    method method of interpolation, str
           Refer to interpolate.interp2d for available options

    Returns
    -------
    Xnew 2d array generated by np.meshgrid
    Ynew 2d array generated by np.meshgrid
    datanew 2d array

    """
    f = interpolate.interp2d(x, y, data, kind=method)

    # make a meshgrid
    xnew, ynew = np.arange(x[0], x[-1] + xint, xint), np.arange(y[0], y[-1] + yint, yint)
    Xnew, Ynew = np.meshgrid(xnew, ynew)
    # interpolate using scipy.interpolate.inter2d
    datanew = f(xnew, ynew)

    return Xnew, Ynew, datanew

def colorbar(mappable, location='right'):
    ax = mappable.axes
    fig = ax.figure
    divider = make_axes_locatable(ax)
    cax = divider.append_axes(location, size='5%', pad=0.05)
    return fig.colorbar(mappable, cax=cax)

def weighted_mean(means, stds):
    """
    Compute weighted arithmetic mean
    Parameters
    ----------
    means : list (floats)
        list of mean values
    stds : list (floats)
        list of standard deviations associated to means

    Returns
    -------
    weighted_mean : float
    """
    return sum(np.asarray(means * (1. / np.asarray(stds)))) / sum(1. / np.asarray(stds))

def weighted_mean_std(stds):
    """
    Compute the uncertainty for a weighted mean
    Parameters
    ----------
    stds : list (floats)
        list of standard deviations associated to means

    Returns
    -------
    weighted_mean_std : float
    """
    return np.sqrt(1. / sum(1. / np.asarray(stds)))

def find_center_of_arr2d(arr):
    """
    Returns a center of 2d array
    For example, if the array contains mass distribution, then this returns the center of mass.
    Parameters
    ----------
    arr

    Returns
    -------

    """
    arr = np.array(arr)
    cx, cy = 0, 0
    for i in range(arr.shape[0]):
        for j in range(arr.shape[1]):
            cx = i * arr[i][j]
            cy = j * arr[i][j]
    cx, cy = cx / arr.sum(), cy / arr.sum()
    return cx, cy

def compute_dist(x1, y1, x2, y2):
    """Compute distance between two points (x1,y1) and (x2,y2)"""
    return np.sqrt((x1-x2)**2. + (y1-y2)**2.)





if __name__ == '__main__':
    """
    Pass a absolute path of the cine files through '-input' e.g. -input '/absolute/path/to/cineDir/*.cine'
    """
    parser = argparse.ArgumentParser(description='')
    parser.add_argument('-input', metavar='input', type=str, nargs='*', default=None, help='')
    parser.add_argument('-NP', dest='NP', type=int, default=800,
                        help='Number of points to sample along the circulation contour')
    parser.add_argument('-min_radius', dest='min_radius', type=float, default=10,
                        help='Smallest radius of circulation contour explored (pixels)')
    parser.add_argument('-max_radius', dest='max_radius', type=float, default=70,
                        help='Largest radius of circulation contour explored (pixels)')
    parser.add_argument('-sample_pts', dest='sample_pts', type=int, default=10,
                        help='number of points between min and max radius at which to sample the circulation')
    parser.add_argument('-cm_shift', dest='cm_shift', type=int, default=10,
                        help='Largest amount to shift the center of the circulation contour')

    parser.add_argument('-scale', dest='scale', type=float, default=None)
    parser.add_argument('-rate', dest='rate', type=float, default=None)

    parser.add_argument('-image_spacing', dest='image_spacing', type=float, default=1,
                        help='number of frames between a image pair')
    parser.add_argument('-frame_spacing', dest='frame_spacing', type=float, default=10,
                        help='number of frames between successive image pairs')
    parser.add_argument('-plot_spacing', dest='plot_spacing', type=int, default=50,
                        help='spacing between circulation curves are plotted and saved')
    parser.add_argument('-box_size', dest='box_size', type=int, default=32)

    parser.add_argument('-start', dest='start', type=int, default=0)
    parser.add_argument('-stop', dest='stop', type=int, default=0)
    parser.add_argument('-skip', dest='skip', type=int, default=10)

    parser.add_argument('-omegabool', dest='omegabool', default=True)

    parser.add_argument('--summarize', dest='summarize', action='store_true', default=False,
                        help='Plot only the aggregate data, assuming that the .json files have already been generated')
    parser.add_argument('--save_circ', dest='save_circ', action='store_true', default=False)

    # PARSE COMMAND LINE INPUTS
    args = parser.parse_args()

    cine_inputs = args.input
    NP = args.NP
    min_radius = args.min_radius
    max_radius = args.max_radius
    sample_pts = args.sample_pts
    cm_shift = args.cm_shift
    summarize = args.summarize
    save_circ = args.save_circ
    scale = args.scale
    rate = args.rate
    image_spacing = args.image_spacing
    frame_spacing = args.frame_spacing
    plot_spacing = args.plot_spacing
    omegabool = args.omegabool
    dt = frame_spacing/rate
    box_size = args.box_size

    # SETUP SOME VARIABLES FOR PLOTTING TO BE USED THROUGHOUT SCRIPT
    radii = np.linspace(min_radius * scale, max_radius * scale, num=sample_pts, endpoint=True)
    radii_diff = (max_radius * scale - min_radius * scale) / float(sample_pts - 1)
    phi = np.arange(NP) * 2 * np.pi / float(NP)

    gammar_all, vr_all, dr_all = [], [], []
    span = []

    for cnum, cine_file in enumerate(cine_inputs):
        # Ring velocity, ring diameter, circulation, vortex rsssing core position(x, y)
        trForVr, vxr, vyr, vr =[], [], [], []
        trForDr, dr = [], []
        trForGammar, gammar, gammar_err, cxmaxlist, cymaxlist, cxminlist, cyminlist = [], [], [], [], [], [], []
        cxlist, cylist = [], []
        time = []

        # LOAD CINE FILE AND GRUB IMAGE SIZE
        movie = cine.open(cine_file)
        imsize = np.shape(movie[0])



        # GENERATE FILE ARCHITECTURE
        date_dir, cine_name = os.path.split(cine_file)
        name, ext = os.path.splitext(cine_name)
        # cine_dir = os.path.join(date_dir, name)
        resultsdir = date_dir + '/PIV_AnalysisResults/' + name  #ABS PATH TO OUTPUT DIRECTORY

        # Get stroke length from name of cine file
        try:
            span = fs.get_float_from_str(name, 'piston', 'mm_freq')
        except ValueError:
            span = float(browse.replace_letter_in_string(span, 'p', '.'))



        print 'Working on Cine file: ', name

        # # CREATE A DIRECTORY TO STORE RESULTS
        # if not os.path.exists(resultsdir):
        #     os.makedirs(resultsdir)

        # CREATE A DIRECTORY TO STORE RESULTS OF CIRCULATION COMPUTATION
        circulation_dir = resultsdir + '/circulation/'
        if not os.path.exists(circulation_dir):
            os.makedirs(circulation_dir)

        # GRAB A DIRECTORY NAME WHERE PIVLAB-GENERATED txt FILES ARE STORED
        data_dir = date_dir + '/PIV_W%s_step%s_data' % (box_size, int(image_spacing)) + \
                   '/PIVlab_ratio2_W%spix_Dt_%s_' % (box_size, int(image_spacing)) + name

        print movie.len



        # CHECK IF DATA FILES(txt FILES GENERATED BY PIVLAB) EXIST
        if not os.path.exists(data_dir):
            print 'NO DATA DIRECTORY FOUND! EXITING'
            print 'data_dir is supposed to be ... ' + data_dir
            sys.exit()

        # INITIALIZE EMTPY LISTS FOR ROBUST GAMMA COMPUTATIONS
        robust_gammas = []
        robust_radii = []
        robust_frames = []
        robust_wav_gammas = []
        robust_wav_stds = []

        # ITERATE THROUGH FRAMES IN CINE FILE
        if args.stop == 0:
            frames = range(args.start, movie.__len__(), args.skip)
        else:
            frames = range(args.start, args.stop, args.skip)
        print 'Working on frame range: (%d:%d)' % (frames[0], frames[-1])

        counter = 0

        for i, f in enumerate(frames):
            # Convert frame to sec
            time.append(f / float(rate))
            if f % plot_spacing == 0:
                print 'Processing frame %d' % f
                print 'image size in px (y,x): ', imsize
                try:
                    i += frames[0] / frame_spacing
                except TypeError:
                    print 'NO FRAME SPACING SPECIFIED! EXITING'
                # Read data from txt files generated by PIVLab
                print 'Attempting to read the txt data from...:'
                print os.path.join(data_dir, 'D%04d.txt' % f)

                if os.path.exists(os.path.join(data_dir, 'D%05d.txt' % f)):
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, 'D%05d.txt' % f))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, 'D%05d.txt' % f))
                    print 'Loaded D%05d.txt' % f
                elif os.path.exists(os.path.join(data_dir, 'D%04d.txt' % f)):
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, 'D%04d.txt' % f))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, 'D%04d.txt' % f))
                    print '...Loaded D%04d.txt' % f
                elif os.path.exists(os.path.join(data_dir, 'D%03d.txt' % f)):
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, 'D%03d.txt' % f))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, 'D%03d.txt' % f))
                    print '...Loaded D%03d.txt' % f
                elif os.path.exists(os.path.join(data_dir, 'D%02d.txt' % f)):
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, 'D%02d.txt' % f))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, 'D%02d.txt' % f))
                    print '...Loaded D%02d.txt' % f
                elif os.path.exists(os.path.join(data_dir, 'D%01d.txt' % f)):
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, 'D%01d.txt' % f))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, 'D%01d.txt' % f))
                    print '...Loaded D%01d.txt' % f
                else:
                    print 'NO DATA EXISTS FOR FRAME: %d; SKIPPING!' % f


                #Clean data by excluding unreasonable values and linearly interpolating excluded data points
                print '---------------'
                print 'Cleaning ux... cutoff is ' + str(cutoffu * scale * rate) + 'mm/s'
                ux = process.clean_multi_dim_array(ux, cutoff=cutoffu, verbose=False)
                print 'Cleaning uy... cutoff is ' + str(cutoffu * scale * rate) + 'mm/s'
                uy = process.clean_multi_dim_array(uy, cutoff=cutoffu, verbose=False)
                print 'Cleaning omega... cutoff is ' + str(cutoffomega * rate) + '1/s'
                omega = process.clean_multi_dim_array(omega, cutoff=cutoffomega, verbose=False)
                print '---------------'
                # Figure out the number of voxels (nx, ny)
                nx, ny = (x[-1] - x[0]) * 2 / box_size + 1, (y[-1] - y[0]) * 2 / box_size + 1

                # Reshape omega into nx x ny array
                xgrid = np.array(x).reshape((nx, ny))
                ygrid = np.array(y).reshape((nx, ny))
                omegagrid = np.array(omega).reshape((nx, ny))
                uxgrid = np.array(ux).reshape((nx, ny))
                uygrid = np.array(uy).reshape((nx, ny))

                # COMPUTE INTERPOLATED VELOCITY AND VORTICITY
                # CONVERT PX -> MM AND FRAME -> SEC
                Xgrid, Ygrid, iuxgrid = interp_flow_component(x * scale, y * scale, ux * scale * rate)
                Xgrid, Ygrid, iuygrid = interp_flow_component(x * scale, y * scale, uy * scale * rate)
                Xgrid, Ygrid, iomegagrid = interp_flow_component(x * scale, y * scale, omega * rate)

                xmin, xmax, ymin, ymax = min(Xgrid.flatten()), max(Xgrid.flatten()),\
                                         min(Ygrid.flatten()), max(Ygrid.flatten())
                print 'Window dimension in mm: (xmin, xmax, ymin, ymax)=(%.2f, %.2f, %.2f, %.2f)'\
                      %(xmin, xmax, ymin, ymax)

                # FIND THE CENTER OF VORTICES  (keep track of negative omegeaz)
                ## Simplest approach is to find a position of the maximum or minimum of vorticity
                # # Keep track of a vortex of positive vorticity
                # cx, cy = Xgrid[max_x, max_y], max(Ygrid.flatten()) - Ygrid[max_x, max_y]
                # Keep track of a vortex of negative vorticity
                # cx, cy = Xgrid[min_x, min_y], max(Ygrid.flatten()) - Ygrid[min_x, min_y]

                # #Method 1: extrema of  vorticity
                # max_x, max_y = where(iomegagrid == max(iomegagrid.flatten()))
                # min_x, min_y = where(iomegagrid == min(iomegagrid.flatten()))
                # print 'Center of vortices- Method 1: ', max_x, max_y
                # cx, cy = Xgrid[min_x, min_y], max(Ygrid.flatten()) - Ygrid[min_x, min_y]

                # Method 2: extrema of vorticity (ignore the edges)]
                # nxedges = int(np.abs((xgrid[1][0] - xgrid[0][0]))/__xint__)
                # nyedges = int(np.abs((ygrid[0][1] - ygrid[0][0]))/__yint__)
                # print nxedges, nyedges
                # iomegagrid_no_edges = iomegagrid[nxedges:-nxedges, nyedges:-nyedges]
                # max_x, max_y = where(iomegagrid == max(iomegagrid_no_edges.flatten()))
                # min_x, min_y = where(iomegagrid == min(iomegagrid_no_edges.flatten()))
                # print 'Center of vortices- Method 2: ', max_x, max_y
                # cx, cy = Xgrid[min_x, min_y], max(Ygrid.flatten()) - Ygrid[min_x, min_y]

                # Method 3: center of vorticity (ignore the edges)]
                nxedges = int(np.abs((xgrid[1][0] - xgrid[0][0])) / __xint__)
                nyedges = int(np.abs((ygrid[0][1] - ygrid[0][0])) / __yint__)
                print 'Number of points ignored from the horizontal and vertical edges: ', nxedges, nyedges

                # Exclude vorticity data at the edges
                iomegagrid_no_edges = iomegagrid[nxedges:-nxedges, nyedges:-nyedges]
                # Find the maximum/minimum value of vorticity in the field
                iomegamax = max(iomegagrid_no_edges.flatten())
                iomegamin = min(iomegagrid_no_edges.flatten())
                # Find a position of maximum/minimum vorticity
                max_x, max_y = np.where(iomegagrid == iomegamax)   # these are indices
                min_x, min_y = np.where(iomegagrid == iomegamin)   # these are indices
                print 'Vortex ring core positions(maximum/minimum omega) in mm: (%.2f, %.2f), (%.2f, %.2f)'\
                    % (Xgrid[int(max_x), int(max_y)], Ygrid[int(max_x), int(max_y)],\
                    Xgrid[int(min_x), int(min_y)], Ygrid[int(min_x), int(min_y)])

                # Extract a fraction of vorticity data around a posion of maximum/minimum vorticity
                nx_frac, ny_frac = int(nxedges / 2.), int(nyedges / 2.)
                iomegagrid_around_max = iomegagrid[int(max_x - nx_frac):int(max_x + nx_frac + 1),
                                        int(max_y - ny_frac):int(max_y + ny_frac + 1)]
                iomegagrid_around_min = iomegagrid[int(min_x - nx_frac):int(min_x + nx_frac + 1),
                                        int(min_y - ny_frac):int(min_y + ny_frac + 1)]
                Xgrid_around_max = Xgrid[int(max_x - nx_frac):int(max_x + nx_frac + 1),
                                   int(max_y - ny_frac):int(max_y + ny_frac + 1)]
                Ygrid_around_max = Ygrid[int(max_x - nx_frac):int(max_x + nx_frac + 1),
                                   int(max_y - ny_frac):int(max_y + ny_frac + 1)]
                Xgrid_around_min = Xgrid[int(min_x - nx_frac):int(min_x + nx_frac + 1),
                                   int(min_y - ny_frac):int(min_y + ny_frac + 1)]
                Ygrid_around_min = Ygrid[int(min_x - nx_frac):int(min_x + nx_frac + 1),
                                   int(min_y - ny_frac):int(min_y + ny_frac + 1)]

                # Find ring core positions weighted by normalized vorticity
                max_xw, max_yw = ndimage.measurements.center_of_mass(iomegagrid_around_max)   # these are indices (decimal)
                min_xw, min_yw = ndimage.measurements.center_of_mass(iomegagrid_around_min)   # these are indices (decimal)

                try:
                    # Track a position of vortex ring core of positive/negative vorticity
                    print max_xw, max_yw, Xgrid_around_max.shape
                    cx = fa.get_values_from_multidim_array_at_coord(Xgrid_around_max, max_xw, max_yw)
                    cy = fa.get_values_from_multidim_array_at_coord(Ygrid_around_max, max_xw, max_yw)
                    print 'Vortex ring core position(Center of Vorticity) in mm: (%.2f, %.2f)' % (cx, cy)
                except IndexError:
                    print 'Tracking vortex ring core is too close to the the edge. SKIPPING...'
                    print '------------------------------'
                    continue

                # CONFIRM THAT CIRCULATION CURVES ARE ALL IN THE FRAME
                # print 'Minimum/Maximum radius:', (radii.min(), radii.max())
                bad_x_path = False
                path_x_limits = radii[-1] * np.cos(phi) + cx   #in mm
                bad_y_path = False
                path_y_limits = radii[-1] * np.sin(phi) + cy   # in mm
                cutoff = ((box_size / 2) + 1) * scale
                # print imsize[0], imsize[1]
                if (path_y_limits <= cutoff).any() or (path_y_limits >= (imsize[0]*scale - cutoff)).any():
                    bad_y_path = True
                if (path_x_limits <= cutoff).any() or (path_x_limits >= (imsize[1]*scale - cutoff)).any():
                    bad_x_path = True
                # print bad_x_path, bad_y_path
                if bad_x_path or bad_y_path:
                    print 'CIRCULATION CURVE NOT IN FRAME, SKIPPING'
                    print '------------------------------'
                    continue

                # SET BOUNDS FOR COLOR BARS
                w_limit = cutoffomega * rate / 1.2
                ux_limit = cutoffu * scale * rate / 1.2
                uy_limit = cutoffu * scale * rate / 1.2

                # Plot
                # Method1-3 has issues with the axes. Data should be rotated by 180, and -90 deg.
                # I should fix this in the near future. - Takumi 2/9/18
                # xphys = x * scale
                # yphys = y * scale
                # #Method 1: pcolormesh
                # ## interpolation may be trickier than imshow
                # w_limit = maximum(max(omega.flatten()), abs(min(omega.flatten())))
                # graph.color_plot(xphys, yphys, omegagrid * rate, vmin=-w_limit, vmax=w_limit, cmap=cmap,fignum=1)
                # graph.colorbar()
                # graph.title('pcolormesh- no interpolation', fignum=1)
                #
                #
                # ##Method 2 pcolormesh + interpolation (use x4 more data points)
                # # interpolate data using scipy.interpolate.interp2d()
                # Xnew, Ynew, omeganew = interp_for_pcolormesh(x, y, omega * rate, xint=16., yint=16.)
                # w_limit = 400
                # graph.color_plot(Xnew, Ynew, omeganew, vmin=-w_limit, vmax=w_limit, cmap=cmap, fignum=2)
                # graph.colorbar(fignum=2)
                # graph.title('pcolormesh- linear interpolation', fignum=2)
                #
                # #Method 3:imshow (raw data)
                ## Various interpolation methods are available
                # graph.imshow(iomegagrid, xmin=x.min(), xmax=x.max(), ymin=y.min(), ymax=y.max(), interpolation='gaussian',\
                #              cmap=cmap,vmin=-w_limit,vmax=w_limit, fignum=3)
                # graph.title('imshow (raw data)' , fignum=3)

                # Method 4: imshow + interpolation on griddata using interpolate.griddata
                # fig, ax, cax, cc = graph.imshow(iomegagrid, xmin=x.min(), xmax=x.max(), ymin=y.min(), ymax=y.max(), interpolation='gaussian',\
                #              cmap=cmap,vmin=-w_limit,vmax=w_limit, fignum=4, cbar=True)
                # graph.title('imshow + interpolation- gaussian', fignum=4)
                # cc.set_label('$\omega_z [1/s]$')


                fig = plt.figure(figsize=(18, 14))
                gs = gridspec.GridSpec(3, 3, width_ratios=[1, 1, 1], height_ratios=[1.5, 1, 2])
                img1 = fig.add_subplot(gs[0])
                for r in radii:
                    img1.plot(r * np.cos(phi) + cx, r * np.sin(phi) + cy, color=cmap(float(r) / float(max(radii))))
                ax1 = img1.imshow(iuxgrid, cmap=cmap2, vmin=-ux_limit, vmax=ux_limit, interpolation='gaussian', \
                                  extent=(xmin, xmax, ymax, ymin))
                img1.set_xlabel('X $[mm]$')
                img1.set_ylabel('Y $[mm]$')
                colorbar(ax1)

                # iUy Plot
                img2 = fig.add_subplot(gs[1])
                for r in radii:
                    img2.plot(r * np.cos(phi) + cx, r * np.sin(phi) + cy, color=cmap(float(r) / float(max(radii))))
                ax2 = img2.imshow(iuygrid, cmap=cmap2, vmin=-uy_limit, vmax=uy_limit, interpolation='gaussian', \
                                  extent=(xmin, xmax, ymax, ymin))
                img2.set_xlabel('X $[mm]$')
                img2.set_ylabel('Y $[mm]$')
                colorbar(ax2)

                # iOmega Plot
                img3 = fig.add_subplot(gs[2])
                for r in radii:
                    img3.plot(r * np.cos(phi) + cx, r * np.sin(phi) + cy, color=cmap(float(r) / float(max(radii))))
                ax3 = img3.imshow(iomegagrid, cmap=cmap2, vmin=-w_limit, vmax=w_limit, interpolation='gaussian', \
                                  extent=(xmin, xmax, ymax, ymin))
                img3.set_xlabel('X $[mm]$')
                img3.set_ylabel('Y $[mm]$')
                colorbar(ax3)

                imgs = [img1, img2, img3]
                titles = ['$u_x$ velocity $(mm/s)$', '$u_y$ velocity $(mm/s)$', '$|\omega|$ $(1/s)$']
                for img, text in zip(imgs, titles):
                    # img.set_xlim([x[0], imsize[1] - x[0]])
                    # img.set_ylim([y[0], imsize[0] - y[0]])
                    # img.set_xticks([])
                    # img.set_yticks([])
                    img.set_title(text)

                    ax4 = plt.subplot(gs[3])
                    ax5 = plt.subplot(gs[4])
                    ax6 = plt.subplot(gs[5])
                    ax4.set_ylabel('velocity $(mm/s)$')

                mean_gs = []
                std_gs = []
                for r in radii:
                    path_x, path_y = r * np.cos(phi) + cx, r * np.sin(phi) + cy
                    iux_p = ndimage.map_coordinates(iuxgrid, (path_y/__yint__, path_x/__xint__), order=1)
                    iuy_p = ndimage.map_coordinates(iuygrid, (path_y/__yint__, path_x/__xint__), order=1)

                    ax4.plot(phi, iux_p, color=cmap(float(r) / float(max(radii))))
                    ax5.plot(phi, iuy_p, color=cmap(float(r) / float(max(radii))))
                    ax6.plot(phi, -iux_p * np.sin(phi) + iuy_p * np.cos(phi), color=cmap(float(r) / float(max(radii))))

                    # CALCULATE AND PLOT CIRCULATIONS AND STATISTICS
                    gammas = []
                    ax7 = plt.subplot(gs[6:])
                    cm_shift_list = np.linspace(-cm_shift * scale, cm_shift * scale, num=10)
                    for off_i in cm_shift_list:
                        for off_j in cm_shift_list:
                            ds = 2 * np.pi * r / float(NP)
                            path_x, path_y = r * np.cos(phi) + cx + off_i, r * np.sin(phi) + cy + off_j
                            iux_p = ndimage.map_coordinates(iuxgrid, (path_y/__yint__, path_x/__xint__), order=1)
                            iuy_p = ndimage.map_coordinates(iuygrid, (path_y/__yint__, path_x/__xint__), order=1)
                            gammas.append(sum((-iux_p * np.sin(phi) + iuy_p * np.cos(phi)) * ds))

                    mean_g = np.mean(np.asarray(gammas))
                    mean_gs.append(mean_g)
                    std_g = np.std(np.asarray(gammas))
                    std_gs.append(std_g)

                    ax7.scatter(r, mean_g, color=cmap(float(r) / float(max(radii))), marker='o')
                    ax7.errorbar(r, mean_g, yerr=std_g, ecolor=cmap(float(r) / float(max(radii))),
                                 elinewidth=2)

                    axes = [ax4, ax5, ax6]
                    titles = ['$u_x$', '$u_y$', r'$u_\theta$']
                    for ax, text in zip(axes, titles):
                        ax.set_title(text)
                        ax.set_xlim([0, 2 * np.pi])
                        ax.set_ylim([-ux_limit, ux_limit])
                        ax.set_xticks((0, np.pi, 2 * np.pi))
                        ax.set_xticklabels(('$0$', '$\pi$', '$2\pi$'))

                    # STORE ROBUST AND WEIGHTED AVERAGE CIRCULATION DATA
                    robust_g = mean_gs[np.argmin(np.asarray(std_gs))]
                    robust_r = radii[np.argmin(np.asarray(std_gs))]
                    weighted_avg = weighted_mean(mean_gs, std_gs)
                    weighted_avg_std = weighted_mean_std(std_gs)

                    # ax7.plot([radii[0], radii[-1]], [weighted_avg, weighted_avg], 'k--')
                    # ax7.plot([radii[0], radii[-1]], [robust_g, robust_g],
                    #         color=cmap(float(robust_r) / float(max(radii))))
                    # ax7.set_ylim([0, 30000])
                    ax7.set_xlabel('countour radius $(mm)$')
                    ax7.set_ylabel('circulation $(mm^2/s)$')
                    ax7.set_title('time: %.4f s' % (f / rate))
                    ax7.set_xlim([0, np.max(radii) + radii_diff])

                    # STORE CIRCULATION DATA IN JSON FORMAT AND SAVE PLOT
                    circulation_data = {'mean_gamma': list(mean_gs),
                                        'std_gamma': list(std_gs),
                                        'radii': list(radii),
                                        'weighted_avg': weighted_avg,
                                        'weighted_avg_std': weighted_avg_std}

                print 'Circulation (weighted avg) in mm2/s: ' + str(weighted_avg)

                # Show results on plot
                gammaavg = np.mean(mean_gs[-5:])
                gammastd = np.mean(std_gs[-5:])
                gammaplusstd = [mean_gs[i] + std_gs[i] for i in range(len(mean_gs))]
                gammaminusstd = [mean_gs[i] - std_gs[i] for i in range(len(mean_gs))]
                ybottom, ytop = ax7.get_ylim()
                textposystep = np.abs(ytop-ybottom) / 10.

                ax7.set_ylim([np.min(gammaminusstd), np.max(gammaplusstd)])
                text = 'highest $\Gamma_{avg}$: ' + str(np.max(mean_gs)) + ' $mm^2/s$'
                ax7.text(radii[-int(0.4 * sample_pts)], ybottom + textposystep * 4, text, fontsize=12)
                text = 'average of last 5 values: ' + str(gammaavg) + ' $mm^2/s$'
                ax7.text(radii[-int(0.4 * sample_pts)], ybottom + textposystep * 3, text, fontsize=12)
                text = 'average of last 5 std : ' + str(gammastd) + ' $mm^2/s$'
                ax7.text(radii[-int(0.4 * sample_pts)], ybottom + textposystep * 2, text, fontsize=12)

                # Save data in json format
                circulation_data_name = 'circulation_data_%06d.json' % f
                circulation_data_file = os.path.join(circulation_dir, circulation_data_name)
                with open(circulation_data_file, 'w') as fyle:
                    json.dump(circulation_data, fyle, sort_keys=True, indent=1, separators=(',', ': '))
                    fyle.close()
                # Save a plot in png
                fig_name = 'circulation_%06d.png' % f
                fig_file = os.path.join(circulation_dir, fig_name)
                plt.savefig(fig_file)
                print 'Saved...' + fig_file
                plt.close()

                # Make a list for ciruclation (take maximum Gamma_mean)
                trForGammar.append(f / float(rate))

                gammar_max_ind, gammar_max = fa.find_max(mean_gs)
                gammar.append(gammar_max)
                gammar_err.append(std_gs[gammar_max_ind])


                # Calculate ring velocity
                cxlist.append(cx)
                cylist.append(cy)
                #trForVr.append(f/float(rate))


                if counter % vrtimestep == 0 and len(cxlist)>vrtimestep:
                    trForVr.append(f / float(rate))
                    if len(trForVr) > 1:
                        # Calculate ring velocity
                        vr.append(compute_dist(cxlist[counter], cylist[counter], cxlist[counter-vrtimestep], cylist[counter-vrtimestep])
                                  / (trForVr[counter/vrtimestep-1]-trForVr[counter/vrtimestep-2]))

                # Calculate ring diameter
                try:
                    cxmax = fa.get_values_from_multidim_array_at_coord(Xgrid_around_max, max_xw, max_yw)
                    cymax = fa.get_values_from_multidim_array_at_coord(Ygrid_around_max, max_xw, max_yw)
                    cxmin = fa.get_values_from_multidim_array_at_coord(Xgrid_around_min, min_xw, min_yw)
                    cymin = fa.get_values_from_multidim_array_at_coord(Ygrid_around_min, min_xw, min_yw)
                    # Append core positions
                    cxmaxlist.append(cxmax)
                    cymaxlist.append(cymax)
                    cxminlist.append(cxmin)
                    cyminlist.append(cymin)
                    trForDr.append(f/float(rate))

                except IndexError:
                    print 'Vortex ring core with negative vorticity was not detected!'
                    continue
                # Compute diameter and append the value to the diameter list
                dr_avg = np.mean(trForDr)
                dri = compute_dist(cxmax, cymax, cxmin, cymin)
                dr.append(dri)

                #Update counter
                counter = counter + 1

                print '------------------------------'

        print '------------------------------'
        print 'PLOTTING TIME-EVOLUTION'

                # graph.show()
        #Clean data about circulation, ring diameter, ring velocity
        trForVr = trForVr[:-1]
        trForGammar, gammar, gammar_err = process.clean_multi_dim_array_trio_using_median(trForGammar, gammar, gammar_err, cutoffratio=0.6, mode='less')
        trForGammar, gammar, gammar_err = process.clean_multi_dim_array_trio_using_median(trForGammar, gammar, gammar_err, cutoffratio=1.3, mode='greater')
        trForVr, vr = process.clean_multi_dim_array_pair_using_median(trForVr, vr, cutoffratio=0.6, mode='less')
        trForVr, vr = process.clean_multi_dim_array_pair_using_median(trForVr, vr, cutoffratio=1.3, mode='greater')
        trForDr, dr = process.clean_multi_dim_array_pair_using_median(trForDr, dr, cutoffratio=0.6, mode='less')
        trForDr, dr = process.clean_multi_dim_array_pair_using_median(trForDr, dr, cutoffratio=1.3, mode='greater')
        trForDr, dr = process.clean_multi_dim_array_pair_using_cutoff(trForDr, dr, cutoff=4., mode='less')

        gammar_avg = np.mean(gammar)
        vr_avg = np.mean(vr)
        dr_avg = np.mean(dr)
        gammar_std = np.std(gammar)
        vr_std = np.std(vr)
        dr_std = np.std(dr)

        #Error processing in case gammar etc. are empty arrays
        if len(trForGammar)==0 or len(trForVr)==0 or len(trForDr)==0:
            fig8 = plt.figure()
            ax = fig8.add_axes([0, 0, 1, 1])
            left, width = .25, .5
            bottom, height = .25, .5
            right = left + width
            top = bottom + height
            ax.text(0.5 * (left + right), 0.5 * (bottom + top), 'No vortex ring was detected!',
                    horizontalalignment='center',
                    verticalalignment='center',
                    fontsize=20, color='red',
                    transform=ax.transAxes)
            savedir = resultsdir + '/time_evolution/'
            filename = 'No_vortex_ring_detected'
            graph.save(savedir + filename, ext='png', close=True)
            continue

        # Plot circulation, ring velocity, and diameter
        #fig8, ax8 = graph.scatter(trForGammar, gammar, fignum=2, subplot=131,figsize=(20, 5))
        fig8, ax8 = graph.errorbar(trForGammar, gammar, yerr=gammar_err, fignum=2,subplot=131, figsize=(20, 5))
        graph.labelaxes(ax8, 'Time ($s$)', 'Circulation ($mm^2/s$)')
        if gammar_avg*1.3 > np.max(gammar):
            graph.setaxes(ax8, 0, time[-1], 0, gammar_avg*1.3)
        else:
           graph.setaxes(ax8, 0, time[-1], 0, np.max(gammar))
        text = 'Average $\Gamma$: %.1f' % gammar_avg + '$mm^2/s$'
        graph.addtext(ax8, x=(time[-1])/10., y=gammar_avg*1.3/4.*2, text=text)
        text = 'Std.: %.1f' % gammar_std + '$mm^2/s$'
        graph.addtext(ax8, x=(time[-1])/10., y=gammar_avg * 1.3 / 4., text=text)


        fig9, ax9 = graph.scatter(trForVr, vr, fignum=2, subplot=132, figsize=(20, 5))
        graph.labelaxes(ax9, 'Time ($s$)', 'Ring velocity ($mm/s$)')
        if vr_avg*1.3 > np.max(vr):
            graph.setaxes(ax9, 0, time[-1], 0, vr_avg*1.3)
        else:
            graph.setaxes(ax9, 0, time[-1], 0, np.max(vr))
        text = 'Average $v_r$: %.1f' % vr_avg + '$mm/s$'
        graph.addtext(ax9, x=(time[-1])/10., y=vr_avg*1.3/4.*2, text=text)
        text = 'Std.: %.1f' % vr_std + '$mm/s$'
        graph.addtext(ax9, x=(time[-1]) / 10., y=vr_avg * 1.3 / 4., text=text)

        fig10, ax10 = graph.scatter(trForDr, dr, fignum=2, subplot=133, figsize=(20, 5))
        graph.labelaxes(ax10, 'Time ($s$)', 'Ring diameter ($mm$)')
        if dr_avg*1.3 > np.max(dr):
            graph.setaxes(ax10, 0, time[-1], 0, dr_avg*1.3)
        else:
            graph.setaxes(ax10, 0, time[-1], 0, np.max(dr))
        text = 'Average $D$: %.1f' % dr_avg + '$mm$'
        graph.addtext(ax10, x=(time[-1])/10., y=dr_avg*1.3/4.*2, text=text)
        text = 'Std.: %.1f' % dr_std + '$mm$'
        graph.addtext(ax10, x=(time[-1])/10., y=dr_avg * 1.3 / 4., text=text)

        savedir = resultsdir + '/time_evolution/'
        filename = 'circulation_vring_diameter'
        graph.save(savedir+filename, ext='png', close=True)

        # Save data in json format
        time_evolution_data = {'trForGammar': trForGammar.tolist(),
                               'gammar': gammar.tolist(),
                               'trForVr': trForVr.tolist(),
                               'vr': vr.tolist(),
                               'trForDr': trForDr.tolist(),
                               'dr': dr.tolist()
                               }

        time_evolution_data_name = 'time_evolution_data.json'
        time_evolution_data_path = savedir + 'time_evolution_data.json'
        with open(time_evolution_data_path, 'w') as fyle:
            json.dump(time_evolution_data, fyle, sort_keys=True, indent=1, separators=(',', ': '))
            fyle.close()

        print '---------------'


    print 'Done'