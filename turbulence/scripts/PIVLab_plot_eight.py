#!/usr/bin/env python
"""
Finds up to four vortex rings and compute circulation, vring, and diameter of each ring
- Computes and plots circulation at every args.plot_spacing frames
= Computes and plots circulation velocity and radius of vortex rings over time
"""
import argparse
import os
import sys
import cine
import json
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import pickle
from matplotlib import cm
from scipy import ndimage, interpolate
from mpl_toolkits.axes_grid1 import make_axes_locatable
from scipy import ndimage
# import ilpm.cine as cine
import numpy as np
import math

from scipy.interpolate import interp1d
from scipy.ndimage import map_coordinates

import library.tools.browse as browse
import library.tools.process_data as process
import library.display.graph as graph
import library.basics.formatstring as fs
import library.basics.formatarray as fa


cmap = cm.spectral
cmap2 = cm.bwr
colorcycle = graph.get_default_color_cycle()

cx_lim = 100
cy_lim = 100

threshold = .08

# cutoff values for cleaning raw data
cutoffu = 4.  #px/frame
cutoffomega = 0.1 #/frame

# new grid spacing in px
__xint__, __yint__ = 1., 1.

# Frequencey of computing ring velocity
vrtimestep = 2  # compute vr every n steps


def load_matlab_data(datapath):
    """Reads data from .txt files generated by PIVlab and places them into numpy arrays

    Parameters
    ----------
    data_loc : str
        The directory containing .txt files generated from PIVlab

    Returns
    -------
    x, y, ux, uy, omega array (floats)
        coordinates, velocity components, and vorticity calculated by PIVlab
    """
    file = open(datapath)
    x, y, ux, uy, omega = [], [], [], [], []
    for i, line in enumerate(file):
        if i < 3:
            continue
        for j, val in enumerate(line.split(',')):
            if j == 0:
                x.append(int(val))
            elif j == 1:
                y.append(int(val))
            elif j == 2:
                ux.append(float(val))
            elif j == 3:
                uy.append(float(val))  # Note that there is a minus sign due to the default coordinate system in PIVLab.
            elif j == 4:
                omega.append(float(val))

    if j == 4:
        x, y, ux, uy, omega = map(lambda z: np.asarray(z), [x, y, ux, uy, omega])
        return x, y, ux, uy, omega
    elif j == 3:
        x, y, ux, uy = map(lambda z: np.asarray(z), [x, y, ux, uy])
        return x, y, ux, uy

def interp_flow_component(x, y, ux, xint=__xint__, yint=__yint__, method='linear'):
    """
    Interpolate x,y, and data (ux) into x_new which has interval of __xint__
    Parameters
    ----------
    x
    y
    ux
    xint
    yint
    method

    Returns
    -------
    Xnew, Ynew: x and y coordinates of a grid
    datanew : 2d numpy array

    """
    uxindicies = [(xx, yy) for xx, yy in zip(x, y)]
    # grid_ind0, grid_ind1 = mgrid[0:imsize[0], 0:imsize[1]]
    # griddata = interpolate.griddata(uxindicies, ux, (grid_ind0, grid_ind1), method=method, fill_value=0.)
    xmin, xmax, ymin, ymax = np.min(x), np.max(x), np.min(y), np.max(y)
    xnew, ynew = np.arange(xmin, xmax + xint, xint), np.arange(ymin, ymax + yint, yint)
    Xnew, Ynew = np.meshgrid(xnew, ynew)
    griddata = interpolate.griddata(uxindicies, ux, (Xnew, Ynew), method=method, fill_value=0.)

    return Xnew, Ynew, griddata

def interp_for_pcolormesh(x, y, data, xint=__xint__, yint=__yint__, method='cubic'):
    """
    (PIVLab only)
    Takes 1d arrays for x, y, data, and generate a grid, interpolate data,
    and give back grids (2d arrays generated by np.meshgrid) and interpolated data
    One can immediately generate a heatmap by using pcolormesh(Xnew, Ynew, datanew)

    Parameters
    ----------
    x 1d array
    y 1d array
    data 1d array
    xint interval of new x, float
    yint interval of new x, float
    method method of interpolation, str
           Refer to interpolate.interp2d for available options

    Returns
    -------
    Xnew 2d array generated by np.meshgrid
    Ynew 2d array generated by np.meshgrid
    datanew 2d array

    """
    f = interpolate.interp2d(x, y, data, kind=method)

    # make a meshgrid
    xnew, ynew = np.arange(x[0], x[-1] + xint, xint), np.arange(y[0], y[-1] + yint, yint)
    Xnew, Ynew = np.meshgrid(xnew, ynew)
    # interpolate using scipy.interpolate.inter2d
    datanew = f(xnew, ynew)

    return Xnew, Ynew, datanew

def colorbar(mappable, location='right'):
    ax = mappable.axes
    fig = ax.figure
    divider = make_axes_locatable(ax)
    cax = divider.append_axes(location, size='5%', pad=0.05)
    return fig.colorbar(mappable, cax=cax)

def weighted_mean(means, stds):
    """
    Compute weighted arithmetic mean
    Parameters
    ----------
    means : list (floats)
        list of mean values
    stds : list (floats)
        list of standard deviations associated to means

    Returns
    -------
    weighted_mean : float
    """
    return sum(np.asarray(means * (1. / np.asarray(stds)))) / sum(1. / np.asarray(stds))

def weighted_mean_std(stds):
    """
    Compute the uncertainty for a weighted mean
    Parameters
    ----------
    stds : list (floats)
        list of standard deviations associated to means

    Returns
    -------
    weighted_mean_std : float
    """
    return np.sqrt(1. / sum(1. / np.asarray(stds)))

def find_center_of_arr2d(arr):
    """
    Returns a center of 2d array
    For example, if the array contains mass distribution, then this returns the center of mass.
    Parameters
    ----------
    arr

    Returns
    -------

    """
    arr = np.array(arr)
    cx, cy = 0, 0
    for i in range(arr.shape[0]):
        for j in range(arr.shape[1]):
            cx = i * arr[i][j]
            cy = j * arr[i][j]
    cx, cy = cx / arr.sum(), cy / arr.sum()
    return cx, cy

def compute_dist(x1, y1, x2, y2):
    """Compute distance between two points (x1,y1) and (x2,y2)"""
    return np.sqrt((x1-x2)**2. + (y1-y2)**2.)

def compute_circulation(iuxgrid, iuygrid, cx, cy, radii, phi, cm_shift, scale):
    for r in radii:
        path_x, path_y = r * np.cos(phi) + cx, r * np.sin(phi) + cy
        iux_p = ndimage.map_coordinates(iuxgrid, (path_y / __yint__, path_x / __xint__), order=1)
        iuy_p = ndimage.map_coordinates(iuygrid, (path_y / __yint__, path_x / __xint__), order=1)

        # CALCULATE AND PLOT CIRCULATIONS AND STATISTICS
        gammas = []
        cm_shift_list = np.linspace(-cm_shift * scale, cm_shift * scale, num=10)
        for off_i in cm_shift_list:
            for off_j in cm_shift_list:
                ds = 2 * np.pi * r / float(NP)
                path_x, path_y = r * np.cos(phi) + cx + off_i, r * np.sin(phi) + cy + off_j
                iux_p = ndimage.map_coordinates(iuxgrid, (path_y / __yint__, path_x / __xint__), order=1)
                iuy_p = ndimage.map_coordinates(iuygrid, (path_y / __yint__, path_x / __xint__), order=1)
                gammas.append(sum((-iux_p * np.sin(phi) + iuy_p * np.cos(phi)) * ds))

        mean_g = np.mean(np.asarray(gammas))
        mean_gs.append(mean_g)
        std_g = np.std(np.asarray(gammas))
        std_gs.append(std_g)
    return radii, mean_gs, std_gs

def update_data_dict(dict, key, subkey, data=[]):
    """
    Generate a dictionary that stores effective velocity
    Parameters
    ----------
    dict
    key: span like span5.4
    subkey: commanded velocity, str
    data: effective velocity, float

    Returns
    -------

    """
    if not key in dict:
        dict[key] = {}  # Generate a sub-dictionary
    dict[key][subkey] = data
    return dict





if __name__ == '__main__':
    """
    Pass a absolute path of the cine files through '-input' e.g. -input '/absolute/path/to/cineDir/*.cine'
    """
    parser = argparse.ArgumentParser(description='')
    parser.add_argument('-input', metavar='input', type=str, nargs='*', default=None, help='')
    parser.add_argument('-NP', dest='NP', type=int, default=800,
                        help='Number of points to sample along the circulation contour')
    parser.add_argument('-min_radius', dest='min_radius', type=float, default=10,
                        help='Smallest radius of circulation contour explored (pixels)')
    parser.add_argument('-max_radius', dest='max_radius', type=float, default=70,
                        help='Largest radius of circulation contour explored (pixels)')
    parser.add_argument('-sample_pts', dest='sample_pts', type=int, default=10,
                        help='number of points between min and max radius at which to sample the circulation')
    parser.add_argument('-cm_shift', dest='cm_shift', type=int, default=10,
                        help='Largest amount to shift the center of the circulation contour')

    parser.add_argument('-scale', dest='scale', type=float, default=None)
    parser.add_argument('-rate', dest='rate', type=float, default=None)

    parser.add_argument('-image_spacing', dest='image_spacing', type=float, default=1,
                        help='number of frames between a image pair')
    parser.add_argument('-frame_spacing', dest='frame_spacing', type=float, default=10,
                        help='number of frames between successive image pairs')
    parser.add_argument('-plot_spacing', dest='plot_spacing', type=int, default=50,
                        help='spacing between circulation curves are plotted and saved')
    parser.add_argument('-box_size', dest='box_size', type=int, default=32)

    parser.add_argument('-start', dest='start', type=int, default=0)
    parser.add_argument('-stop', dest='stop', type=int, default=0)
    parser.add_argument('-skip', dest='skip', type=int, default=10)

    parser.add_argument('-omegabool', dest='omegabool', default=True)

    parser.add_argument('--summarize', dest='summarize', action='store_true', default=False,
                        help='Plot only the aggregate data, assuming that the .json files have already been generated')
    parser.add_argument('--save_circ', dest='save_circ', action='store_true', default=False)

    # PARSE COMMAND LINE INPUTS
    args = parser.parse_args()

    cine_inputs = args.input
    NP = args.NP
    min_radius = args.min_radius
    max_radius = args.max_radius
    sample_pts = args.sample_pts
    cm_shift = args.cm_shift
    summarize = args.summarize
    save_circ = args.save_circ
    scale = args.scale
    rate = args.rate
    image_spacing = args.image_spacing
    frame_spacing = args.frame_spacing
    plot_spacing = args.plot_spacing
    omegabool = args.omegabool
    dt = frame_spacing/rate
    box_size = args.box_size

    # SETUP SOME VARIABLES FOR PLOTTING TO BE USED THROUGHOUT SCRIPT
    radii = np.linspace(min_radius * scale, max_radius * scale, num=sample_pts, endpoint=True)
    radii_diff = (max_radius * scale - min_radius * scale) / float(sample_pts - 1)
    phi = np.arange(NP) * 2 * np.pi / float(NP)

    gammar_all, vr_all, dr_all = [], [], []
    span = []

    data_dict = {}
    # for plots
    gammar_lim, vr_lim, dr_lim = 0, 0, 0
    colors = graph.get_first_n_colors_from_color_cycle(4)  # colors corresponding to domains

    for cnum, cine_file in enumerate(cine_inputs):
        # Ring velocity, ring diameter, circulation, vortex rsssing core position(x, y)
        trForVr, vxr, vyr, vr =[], [], [], []
        trForDr, dr = [], []
        trForGammarPos, gammarPos, gammarPos_err, cxmaxlist, cymaxlist, cxminlist, cyminlist = [], [], [], [], [], [], []
        cxlist, cylist = [], []
        time = []

        # LOAD CINE FILE AND GRUB IMAGE SIZE
        movie = cine.open(cine_file)
        imsize = np.shape(movie[0])



        # GENERATE FILE ARCHITECTURE
        date_dir, cine_name = os.path.split(cine_file)
        name, ext = os.path.splitext(cine_name)
        # cine_dir = os.path.join(date_dir, name)
        resultsdir = date_dir + '/PIV_AnalysisResults/' + name  #ABS PATH TO OUTPUT DIRECTORY

        # Get stroke length from name of cine file
        try:
            span = fs.get_float_from_str(name, 'piston', 'mm_freq')
        except ValueError:
            span = float(browse.replace_letter_in_string(span, 'p', '.'))



        print 'Working on Cine file: ', name

        # # CREATE A DIRECTORY TO STORE RESULTS
        # if not os.path.exists(resultsdir):
        #     os.makedirs(resultsdir)

        # CREATE A DIRECTORY TO STORE RESULTS OF CIRCULATION COMPUTATION
        circulation_dir = resultsdir + '/circulation/'
        if not os.path.exists(circulation_dir):
            os.makedirs(circulation_dir)

        # GRAB A DIRECTORY NAME WHERE PIVLAB-GENERATED txt FILES ARE STORED
        data_dir = date_dir + '/PIV_W%s_step%s_data' % (box_size, int(image_spacing)) + \
                   '/PIVlab_ratio2_W%spix_Dt_%s_' % (box_size, int(image_spacing)) + name

        print movie.len



        # CHECK IF DATA FILES(txt FILES GENERATED BY PIVLAB) EXIST
        if not os.path.exists(data_dir):
            print 'NO DATA DIRECTORY FOUND! EXITING'
            print 'data_dir is supposed to be ... ' + data_dir
            sys.exit()

        # INITIALIZE EMTPY LISTS FOR ROBUST GAMMA COMPUTATIONS
        robust_gammas = []
        robust_radii = []
        robust_frames = []
        robust_wav_gammas = []
        robust_wav_stds = []

        # ITERATE THROUGH FRAMES IN CINE FILE
        if args.stop == 0:
            frames = range(args.start, movie.__len__(), args.skip)
        else:
            frames = range(args.start, args.stop, args.skip)
        print 'Working on frame range: (%d:%d)' % (frames[0], frames[-1])

        # Counters for velocity computation
        # counter = 0
        counter_dict = {'domain1Pos':0, 'domain2Pos':0, 'domain3Pos':0, 'domain4Pos':0,
                        'domain1Neg': 0, 'domain2Neg': 0, 'domain3Neg': 0, 'domain4Neg': 0}
        # Initialize data dictionaries
        for domain_num in range(1, 5):
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'trForGammarPos', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'trForGammarNeg', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'trForVrPos', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'trForVrNeg', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'trForDr', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'gammarPos', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'gammarPos_err', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'gammarNeg', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'gammarNeg_err', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'cxmaxlist', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'cymaxlist', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'cxminlist', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'cyminlist', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'vrPos', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'vrNeg', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'dr', [])

        # Read PIVLab data of the corresponding cine, and compute circulation, ring vel, and diameter
        for i, f in enumerate(frames):
            # Convert frame to sec
            time.append(f / float(rate))


            if f % plot_spacing == 0:
                print 'Processing frame %d' % f
                print 'image size in px (y,x): ', imsize
                try:
                    i += frames[0] / frame_spacing
                except TypeError:
                    print 'NO FRAME SPACING SPECIFIED! EXITING'
                # Read data from txt files generated by PIVLab
                print 'Attempting to read the txt data from...:'
                print os.path.join(data_dir, 'D%04d.txt' % f)

                if os.path.exists(os.path.join(data_dir, 'D%05d.txt' % f)):
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, 'D%05d.txt' % f))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, 'D%05d.txt' % f))
                    print 'Loaded D%05d.txt' % f
                elif os.path.exists(os.path.join(data_dir, 'D%04d.txt' % f)):
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, 'D%04d.txt' % f))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, 'D%04d.txt' % f))
                    print '...Loaded D%04d.txt' % f
                elif os.path.exists(os.path.join(data_dir, 'D%03d.txt' % f)):
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, 'D%03d.txt' % f))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, 'D%03d.txt' % f))
                    print '...Loaded D%03d.txt' % f
                elif os.path.exists(os.path.join(data_dir, 'D%02d.txt' % f)):
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, 'D%02d.txt' % f))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, 'D%02d.txt' % f))
                    print '...Loaded D%02d.txt' % f
                elif os.path.exists(os.path.join(data_dir, 'D%01d.txt' % f)):
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, 'D%01d.txt' % f))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, 'D%01d.txt' % f))
                    print '...Loaded D%01d.txt' % f
                else:
                    print 'NO DATA EXISTS FOR FRAME: %d; SKIPPING!' % f


                #Clean data by excluding unreasonable values and linearly interpolating excluded data points
                print '---------------'
                print 'Cleaning ux... cutoff is ' + str(cutoffu * scale * rate) + 'mm/s'
                ux = process.clean_multi_dim_array(ux, cutoff=cutoffu, verbose=False)
                print 'Cleaning uy... cutoff is ' + str(cutoffu * scale * rate) + 'mm/s'
                uy = process.clean_multi_dim_array(uy, cutoff=cutoffu, verbose=False)
                print 'Cleaning omega... cutoff is ' + str(cutoffomega * rate) + '1/s'
                omega = process.clean_multi_dim_array(omega, cutoff=cutoffomega, verbose=False)
                print '---------------'
                # Figure out the number of voxels (nx, ny)
                nx, ny = (x[-1] - x[0]) * 2 / box_size + 1, (y[-1] - y[0]) * 2 / box_size + 1

                # Reshape omega into nx x ny array
                xgrid = np.array(x).reshape((nx, ny))
                ygrid = np.array(y).reshape((nx, ny))
                omegagrid = np.array(omega).reshape((nx, ny))
                uxgrid = np.array(ux).reshape((nx, ny))
                uygrid = np.array(uy).reshape((nx, ny))

                # COMPUTE INTERPOLATED VELOCITY AND VORTICITY
                # CONVERT PX -> MM AND FRAME -> SEC
                Xgrid, Ygrid, iuxgrid = interp_flow_component(x * scale, y * scale, ux * scale * rate)
                Xgrid, Ygrid, iuygrid = interp_flow_component(x * scale, y * scale, uy * scale * rate)
                Xgrid, Ygrid, iomegagrid = interp_flow_component(x * scale, y * scale, omega * rate)

                xmin, xmax, ymin, ymax = min(Xgrid.flatten()), max(Xgrid.flatten()),\
                                         min(Ygrid.flatten()), max(Ygrid.flatten())
                print 'Window dimension in mm: (xmin, xmax, ymin, ymax)=(%.2f, %.2f, %.2f, %.2f)'\
                      %(xmin, xmax, ymin, ymax)

                # # # Divide the interpolated grids into four domains
                ################################
                #        -> x
                #   |           rx        1-rx
                # y v       <---------><--------->
                #        ^ | Domain 1 | Domain 3 |
                #     ry | |          |          |
                #        v  _____________________
                #        ^ |          |          |
                #  1-ry  | |          |          |
                #        v | Domain 2 | Domain 4 |
                ################################
                Xgrid1, Xgrid2, Xgrid3, Xgrid4 = fa.divide_2d_array_into_four_domains(Xgrid, rx=0.5, ry=0.6)
                Ygrid1, Ygrid2, Ygrid3, Ygrid4 = fa.divide_2d_array_into_four_domains(Ygrid, rx=0.5, ry=0.6)
                iomegagrid1, iomegagrid2, iomegagrid3, iomegagrid4 = fa.divide_2d_array_into_four_domains(iomegagrid, rx=0.5, ry=0.6)


                # Find the center of vorticity (ignore the edges)]
                nxedges = int(np.abs((xgrid[1][0] - xgrid[0][0])) / __xint__)
                nyedges = int(np.abs((ygrid[0][1] - ygrid[0][0])) / __yint__)
                print 'Number of points ignored from the horizontal and vertical edges: ', nxedges, nyedges

                # Exclude vorticity data at the edges
                iomegagrid_no_edges = iomegagrid[nxedges:-nxedges, nyedges:-nyedges]
                iomegagrid1_no_edges, iomegagrid2_no_edges = iomegagrid1[nxedges:, nyedges:], iomegagrid2[nxedges:, :-nyedges]
                iomegagrid3_no_edges, iomegagrid4_no_edges = iomegagrid3[:-nxedges, nyedges:], iomegagrid4[:-nxedges, :-nyedges]
                Xgrid_no_edges = Xgrid[nxedges:-nxedges, nyedges:-nyedges]
                Ygrid_no_edges = Ygrid[nxedges:-nxedges, nyedges:-nyedges]


                # Divide the grids into four domains
                # iomegagrid1_no_edges, iomegagrid2_no_edges,\
                # iomegagrid3_no_edges, iomegagrid4_no_edges = fa.divide_2d_array_into_four_domains(iomegagrid_no_edges, rx=0.5, ry=0.6)
                iomegagrid1_no_edges, iomegagrid2_no_edges = iomegagrid1[nxedges:, nyedges:], iomegagrid2[nxedges:, :-nyedges]
                iomegagrid3_no_edges, iomegagrid4_no_edges = iomegagrid3[:-nxedges, nyedges:], iomegagrid4[:-nxedges, :-nyedges]

                # Find the maximum/minimum value of vorticity in each domain
                iomegamax1 = max(iomegagrid1_no_edges.flatten())
                iomegamin1 = min(iomegagrid1_no_edges.flatten())
                iomegamax2 = max(iomegagrid2_no_edges.flatten())
                iomegamin2 = min(iomegagrid2_no_edges.flatten())
                iomegamax3 = max(iomegagrid3_no_edges.flatten())
                iomegamin3 = min(iomegagrid3_no_edges.flatten())
                iomegamax4 = max(iomegagrid4_no_edges.flatten())
                iomegamin4 = min(iomegagrid4_no_edges.flatten())


                # Find a position of maximum/minimum vorticity
                max_x1, max_y1 = np.where(iomegagrid1 == iomegamax1)   # these are indices
                min_x1, min_y1 = np.where(iomegagrid1 == iomegamin1)   # these are indices
                max_x2, max_y2 = np.where(iomegagrid2 == iomegamax2)   # these are indices
                min_x2, min_y2 = np.where(iomegagrid2 == iomegamin2)   # these are indices
                max_x3, max_y3 = np.where(iomegagrid3 == iomegamax3)   # these are indices
                min_x3, min_y3 = np.where(iomegagrid3 == iomegamin3)   # these are indices
                max_x4, max_y4 = np.where(iomegagrid4 == iomegamax4)   # these are indices
                min_x4, min_y4 = np.where(iomegagrid4 == iomegamin4)   # these are indices



                print 'Vortex ring core positions1(maximum/minimum omega) in mm: (%.2f, %.2f), (%.2f, %.2f)'\
                    % (Xgrid1[int(max_x1), int(max_y1)], Ygrid1[int(max_x1), int(max_y1)],
                       Xgrid1[int(min_x1), int(min_y1)], Ygrid1[int(min_x1), int(min_y1)])
                print 'Vortex ring core positions2(maximum/minimum omega) in mm: (%.2f, %.2f), (%.2f, %.2f)'\
                    % (Xgrid2[int(max_x2), int(max_y2)], Ygrid2[int(max_x2), int(max_y2)],
                       Xgrid2[int(min_x2), int(min_y2)], Ygrid2[int(min_x2), int(min_y2)])
                print 'Vortex ring core positions3(maximum/minimum omega) in mm: (%.2f, %.2f), (%.2f, %.2f)'\
                    % (Xgrid3[int(max_x3), int(max_y3)], Ygrid3[int(max_x3), int(max_y3)],
                       Xgrid3[int(min_x3), int(min_y3)], Ygrid3[int(min_x3), int(min_y3)])
                print 'Vortex ring core positions4(maximum/minimum omega) in mm: (%.2f, %.2f), (%.2f, %.2f)'\
                    % (Xgrid4[int(max_x4), int(max_y4)], Ygrid4[int(max_x4), int(max_y4)],
                       Xgrid4[int(min_x4), int(min_y4)], Ygrid4[int(min_x4), int(min_y4)])

                # Extract a fraction of vorticity data around a position of maximum/minimum vorticity
                nx_frac, ny_frac = int(nxedges / 2.), int(nyedges / 2.)
                iomegagrid_around_max1 = iomegagrid1[int(max_x1 - nx_frac):int(max_x1 + nx_frac + 1),
                                        int(max_y1 - ny_frac):int(max_y1 + ny_frac + 1)]
                iomegagrid_around_min1 = iomegagrid1[int(min_x1 - nx_frac):int(min_x1 + nx_frac + 1),
                                        int(min_y1 - ny_frac):int(min_y1 + ny_frac + 1)]
                iomegagrid_around_max2 = iomegagrid2[int(max_x2 - nx_frac):int(max_x2 + nx_frac + 1),
                                        int(max_y2 - ny_frac):int(max_y2 + ny_frac + 1)]
                iomegagrid_around_min2 = iomegagrid2[int(min_x2 - nx_frac):int(min_x2 + nx_frac + 1),
                                        int(min_y2 - ny_frac):int(min_y2 + ny_frac + 1)]
                iomegagrid_around_max3 = iomegagrid3[int(max_x3 - nx_frac):int(max_x3 + nx_frac + 1),
                                        int(max_y3 - ny_frac):int(max_y3 + ny_frac + 1)]
                iomegagrid_around_min3 = iomegagrid3[int(min_x3 - nx_frac):int(min_x3 + nx_frac + 1),
                                        int(min_y3 - ny_frac):int(min_y3 + ny_frac + 1)]
                iomegagrid_around_max4 = iomegagrid4[int(max_x4 - nx_frac):int(max_x4 + nx_frac + 1),
                                        int(max_y4 - ny_frac):int(max_y4 + ny_frac + 1)]
                iomegagrid_around_min4 = iomegagrid4[int(min_x4 - nx_frac):int(min_x4 + nx_frac + 1),
                                        int(min_y4 - ny_frac):int(min_y4 + ny_frac + 1)]
                # Make a small region around the max and min of vorticity in each domain
                Xgrid_around_max1 = Xgrid1[int(max_x1 - nx_frac):int(max_x1 + nx_frac + 1),
                                   int(max_y1 - ny_frac):int(max_y1 + ny_frac + 1)]
                Ygrid_around_max1 = Ygrid1[int(max_x1 - nx_frac):int(max_x1 + nx_frac + 1),
                                   int(max_y1 - ny_frac):int(max_y1 + ny_frac + 1)]
                Xgrid_around_min1 = Xgrid1[int(min_x1 - nx_frac):int(min_x1 + nx_frac + 1),
                                   int(min_y1 - ny_frac):int(min_y1 + ny_frac + 1)]
                Ygrid_around_min1 = Ygrid1[int(min_x1 - nx_frac):int(min_x1 + nx_frac + 1),
                                   int(min_y1 - ny_frac):int(min_y1 + ny_frac + 1)]
                Xgrid_around_max2 = Xgrid2[int(max_x2 - nx_frac):int(max_x2 + nx_frac + 1),
                                   int(max_y2 - ny_frac):int(max_y2 + ny_frac + 1)]
                Ygrid_around_max2 = Ygrid2[int(max_x2 - nx_frac):int(max_x2 + nx_frac + 1),
                                   int(max_y2 - ny_frac):int(max_y2 + ny_frac + 1)]
                Xgrid_around_min2 = Xgrid2[int(min_x2 - nx_frac):int(min_x2 + nx_frac + 1),
                                   int(min_y2 - ny_frac):int(min_y2 + ny_frac + 1)]
                Ygrid_around_min2 = Ygrid2[int(min_x2 - nx_frac):int(min_x2 + nx_frac + 1),
                                   int(min_y2 - ny_frac):int(min_y2 + ny_frac + 1)]
                Xgrid_around_max3 = Xgrid3[int(max_x3 - nx_frac):int(max_x3 + nx_frac + 1),
                                   int(max_y3 - ny_frac):int(max_y3 + ny_frac + 1)]
                Ygrid_around_max3 = Ygrid3[int(max_x3 - nx_frac):int(max_x3 + nx_frac + 1),
                                   int(max_y3 - ny_frac):int(max_y3 + ny_frac + 1)]
                Xgrid_around_min3 = Xgrid3[int(min_x3 - nx_frac):int(min_x3 + nx_frac + 1),
                                   int(min_y3 - ny_frac):int(min_y3 + ny_frac + 1)]
                Ygrid_around_min3 = Ygrid3[int(min_x3 - nx_frac):int(min_x3 + nx_frac + 1),
                                   int(min_y3 - ny_frac):int(min_y3 + ny_frac + 1)]
                Xgrid_around_max4 = Xgrid4[int(max_x4 - nx_frac):int(max_x4 + nx_frac + 1),
                                   int(max_y4 - ny_frac):int(max_y4 + ny_frac + 1)]
                Ygrid_around_max4 = Ygrid4[int(max_x4 - nx_frac):int(max_x4 + nx_frac + 1),
                                   int(max_y4 - ny_frac):int(max_y4 + ny_frac + 1)]
                Xgrid_around_min4 = Xgrid4[int(min_x4 - nx_frac):int(min_x4 + nx_frac + 1),
                                   int(min_y4 - ny_frac):int(min_y4 + ny_frac + 1)]
                Ygrid_around_min4 = Ygrid4[int(min_x4 - nx_frac):int(min_x4 + nx_frac + 1),
                                   int(min_y4 - ny_frac):int(min_y4 + ny_frac + 1)]


                # Find ring core positions weighted by normalized vorticity
                max_xw1, max_yw1 = ndimage.measurements.center_of_mass(iomegagrid_around_max1)   # these are indices (decimal)
                min_xw1, min_yw1 = ndimage.measurements.center_of_mass(iomegagrid_around_min1)   # these are indices (decimal)
                max_xw2, max_yw2 = ndimage.measurements.center_of_mass(iomegagrid_around_max2)   # these are indices (decimal)
                min_xw2, min_yw2 = ndimage.measurements.center_of_mass(iomegagrid_around_min2)   # these are indices (decimal)
                max_xw3, max_yw3 = ndimage.measurements.center_of_mass(iomegagrid_around_max3)   # these are indices (decimal)
                min_xw3, min_yw3 = ndimage.measurements.center_of_mass(iomegagrid_around_min3)   # these are indices (decimal)
                max_xw4, max_yw4 = ndimage.measurements.center_of_mass(iomegagrid_around_max4)   # these are indices (decimal)
                min_xw4, min_yw4 = ndimage.measurements.center_of_mass(iomegagrid_around_min4)   # these are indices (decimal)

                print max_xw1, max_yw1, min_xw1, min_yw1


                try:
                    # Track a position of vortex ring core of positive/negative vorticity
                    print max_xw1, max_yw1, Xgrid_around_max1.shape
                    cx_max_dict, cy_max_dict, cx_min_dict, cy_min_dict = {}, {}, {}, {}
                    cx_max_dict["domain1"] = fa.get_values_from_multidim_array_at_coord(Xgrid_around_max1, max_xw1, max_yw1)
                    cy_max_dict["domain1"] = fa.get_values_from_multidim_array_at_coord(Ygrid_around_max1, max_xw1, max_yw1)
                    cx_max_dict["domain2"] = fa.get_values_from_multidim_array_at_coord(Xgrid_around_max2, max_xw2, max_yw2)
                    cy_max_dict["domain2"] = fa.get_values_from_multidim_array_at_coord(Ygrid_around_max2, max_xw2, max_yw2)
                    cx_max_dict["domain3"] = fa.get_values_from_multidim_array_at_coord(Xgrid_around_max3, max_xw3, max_yw3)
                    cy_max_dict["domain3"] = fa.get_values_from_multidim_array_at_coord(Ygrid_around_max3, max_xw3, max_yw3)
                    cx_max_dict["domain4"] = fa.get_values_from_multidim_array_at_coord(Xgrid_around_max4, max_xw4, max_yw4)
                    cy_max_dict["domain4"] = fa.get_values_from_multidim_array_at_coord(Ygrid_around_max4, max_xw4, max_yw4)
                    cx_min_dict["domain1"] = fa.get_values_from_multidim_array_at_coord(Xgrid_around_min1, min_xw1, min_yw1)
                    cy_min_dict["domain1"] = fa.get_values_from_multidim_array_at_coord(Ygrid_around_min1, min_xw1, min_yw1)
                    cx_min_dict["domain2"] = fa.get_values_from_multidim_array_at_coord(Xgrid_around_min2, min_xw2, min_yw2)
                    cy_min_dict["domain2"] = fa.get_values_from_multidim_array_at_coord(Ygrid_around_min2, min_xw2, min_yw2)
                    cx_min_dict["domain3"] = fa.get_values_from_multidim_array_at_coord(Xgrid_around_min3, min_xw3, min_yw3)
                    cy_min_dict["domain3"] = fa.get_values_from_multidim_array_at_coord(Ygrid_around_min3, min_xw3, min_yw3)
                    cx_min_dict["domain4"] = fa.get_values_from_multidim_array_at_coord(Xgrid_around_min4, min_xw4, min_yw4)
                    cy_min_dict["domain4"] = fa.get_values_from_multidim_array_at_coord(Ygrid_around_min4, min_xw4, min_yw4)
                    print 'Vortex ring core position(Center of Vorticity) in mm: (%.2f, %.2f)' % (cx_max_dict["domain1"], cy_max_dict["domain1"])
                    # Compute distances between counterrotating cores
                    d12 = compute_dist(cx_max_dict["domain1"], cy_max_dict["domain1"], cx_min_dict["domain2"], cy_min_dict["domain2"])
                    d13 = compute_dist(cx_min_dict["domain1"], cy_min_dict["domain1"], cx_max_dict["domain3"], cy_max_dict["domain3"])
                    d24 = compute_dist(cx_max_dict["domain2"], cy_max_dict["domain2"], cx_min_dict["domain4"], cy_min_dict["domain4"]) # these are not usually measured correctly
                    d34 = compute_dist(cx_min_dict["domain3"], cy_min_dict["domain3"], cx_max_dict["domain4"], cy_max_dict["domain4"]) # these are not usually measured correctly

                except IndexError:
                    print 'Tracking vortex ring core is too close to the the edge. SKIPPING...'
                    print '------------------------------'
                    continue


                for domain_num in range(1, 5):
                    # Compute circulation with cores with positive/negative vorticity
                    cxmax = cx_max_dict["domain{0}".format(domain_num)]
                    cymax = cy_max_dict["domain{0}".format(domain_num)]
                    cxmin = cx_min_dict["domain{0}".format(domain_num)]
                    cymin = cy_min_dict["domain{0}".format(domain_num)]

                    # Plot the circulation curve for positive core
                    # CONFIRM THAT CIRCULATION CURVES ARE ALL IN THE FRAME
                    bad_x_path = False
                    path_x_limits = radii[-1] * np.cos(phi) + cxmax   #in mm
                    bad_y_path = False
                    path_y_limits = radii[-1] * np.sin(phi) + cymax   # in mm
                    cutoff = ((box_size / 2) + 1) * scale
                    # print imsize[0], imsize[1]
                    if (path_y_limits <= cutoff).any() or (path_y_limits >= (imsize[0]*scale - cutoff)).any():
                        bad_y_path = True
                    if (path_x_limits <= cutoff).any() or (path_x_limits >= (imsize[1]*scale - cutoff)).any():
                        bad_x_path = True
                    # print bad_x_path, bad_y_path
                    if bad_x_path or bad_y_path:
                        print 'CIRCULATION CURVE NOT IN FRAME, SKIPPING'
                        print '------------------------------'
                        continue

                    # SET BOUNDS FOR COLOR BARS
                    w_limit = cutoffomega * rate / 1.2
                    ux_limit = cutoffu * scale * rate / 1.2
                    uy_limit = cutoffu * scale * rate / 1.2

                    # Plot
                    # Method1-3 has issues with the axes. Data should be rotated by 180, and -90 deg.
                    # I should fix this in the near future. - Takumi 2/9/18
                    # xphys = x * scale
                    # yphys = y * scale
                    # #Method 1: pcolormesh
                    # ## interpolation may be trickier than imshow
                    # w_limit = maximum(max(omega.flatten()), abs(min(omega.flatten())))
                    # graph.color_plot(xphys, yphys, omegagrid * rate, vmin=-w_limit, vmax=w_limit, cmap=cmap,fignum=1)
                    # graph.colorbar()
                    # graph.title('pcolormesh- no interpolation', fignum=1)
                    #
                    #
                    # ##Method 2 pcolormesh + interpolation (use x4 more data points)
                    # # interpolate data using scipy.interpolate.interp2d()
                    # Xnew, Ynew, omeganew = interp_for_pcolormesh(x, y, omega * rate, xint=16., yint=16.)
                    # w_limit = 400
                    # graph.color_plot(Xnew, Ynew, omeganew, vmin=-w_limit, vmax=w_limit, cmap=cmap, fignum=2)
                    # graph.colorbar(fignum=2)
                    # graph.title('pcolormesh- linear interpolation', fignum=2)
                    #
                    # #Method 3:imshow (raw data)
                    ## Various interpolation methods are available
                    # graph.imshow(iomegagrid, xmin=x.min(), xmax=x.max(), ymin=y.min(), ymax=y.max(), interpolation='gaussian',\
                    #              cmap=cmap,vmin=-w_limit,vmax=w_limit, fignum=3)
                    # graph.title('imshow (raw data)' , fignum=3)

                    # Method 4: imshow + interpolation on griddata using interpolate.griddata
                    # fig, ax, cax, cc = graph.imshow(iomegagrid, xmin=x.min(), xmax=x.max(), ymin=y.min(), ymax=y.max(), interpolation='gaussian',\
                    #              cmap=cmap,vmin=-w_limit,vmax=w_limit, fignum=4, cbar=True)
                    # graph.title('imshow + interpolation- gaussian', fignum=4)
                    # cc.set_label('$\omega_z [1/s]$')

                    fig = plt.figure(figsize=(18, 14))
                    gs = gridspec.GridSpec(3, 3, width_ratios=[1, 1, 1], height_ratios=[1.5, 1, 2])
                    img1 = fig.add_subplot(gs[0])
                    for r in radii:
                        img1.plot(r * np.cos(phi) + cxmax, r * np.sin(phi) + cymax, color=cmap(float(r) / float(max(radii))))
                    ax1 = img1.imshow(iuxgrid, cmap=cmap2, vmin=-ux_limit, vmax=ux_limit, interpolation='gaussian', \
                                      extent=(xmin, xmax, ymax, ymin))
                    img1.set_xlabel('X $[mm]$')
                    img1.set_ylabel('Y $[mm]$')
                    colorbar(ax1)

                    # iUy Plot
                    img2 = fig.add_subplot(gs[1])
                    for r in radii:
                        img2.plot(r * np.cos(phi) + cxmax, r * np.sin(phi) + cymax, color=cmap(float(r) / float(max(radii))))
                    ax2 = img2.imshow(iuygrid, cmap=cmap2, vmin=-uy_limit, vmax=uy_limit, interpolation='gaussian', \
                                      extent=(xmin, xmax, ymax, ymin))
                    img2.set_xlabel('X $[mm]$')
                    img2.set_ylabel('Y $[mm]$')
                    colorbar(ax2)

                    # iOmega Plot
                    img3 = fig.add_subplot(gs[2])
                    for r in radii:
                        img3.plot(r * np.cos(phi) + cxmax, r * np.sin(phi) + cymax, color=cmap(float(r) / float(max(radii))))
                    ax3 = img3.imshow(iomegagrid, cmap=cmap2, vmin=-w_limit, vmax=w_limit, interpolation='gaussian', \
                                      extent=(xmin, xmax, ymax, ymin))
                    img3.set_xlabel('X $[mm]$')
                    img3.set_ylabel('Y $[mm]$')
                    colorbar(ax3)

                    imgs = [img1, img2, img3]
                    titles = ['$u_x$ velocity $(mm/s)$', '$u_y$ velocity $(mm/s)$', '$\omega_z$ $(1/s)$']
                    for img, text in zip(imgs, titles):
                        # img.set_xlim([x[0], imsize[1] - x[0]])
                        # img.set_ylim([y[0], imsize[0] - y[0]])
                        # img.set_xticks([])
                        # img.set_yticks([])
                        img.set_title(text)

                        ax4 = plt.subplot(gs[3])
                        ax5 = plt.subplot(gs[4])
                        ax6 = plt.subplot(gs[5])
                        ax4.set_ylabel('velocity $(mm/s)$')

                    mean_gs = []
                    std_gs = []
                    for r in radii:
                        path_x, path_y = r * np.cos(phi) + cxmax, r * np.sin(phi) + cymax
                        iux_p = ndimage.map_coordinates(iuxgrid, (path_y / __yint__, path_x / __xint__), order=1)
                        iuy_p = ndimage.map_coordinates(iuygrid, (path_y / __yint__, path_x / __xint__), order=1)

                        ax4.plot(phi, iux_p, color=cmap(float(r) / float(max(radii))))
                        ax5.plot(phi, iuy_p, color=cmap(float(r) / float(max(radii))))
                        ax6.plot(phi, -iux_p * np.sin(phi) + iuy_p * np.cos(phi),
                                 color=cmap(float(r) / float(max(radii))))

                        # CALCULATE AND PLOT CIRCULATIONS AND STATISTICS
                        gammas = []
                        ax7 = plt.subplot(gs[6:])
                        cm_shift_list = np.linspace(-cm_shift * scale, cm_shift * scale, num=10)
                        for off_i in cm_shift_list:
                            for off_j in cm_shift_list:
                                ds = 2 * np.pi * r / float(NP)
                                path_x, path_y = r * np.cos(phi) + cxmax + off_i, r * np.sin(phi) + cymax + off_j
                                iux_p = ndimage.map_coordinates(iuxgrid, (path_y / __yint__, path_x / __xint__),
                                                                order=1)
                                iuy_p = ndimage.map_coordinates(iuygrid, (path_y / __yint__, path_x / __xint__),
                                                                order=1)
                                gammas.append(sum((-iux_p * np.sin(phi) + iuy_p * np.cos(phi)) * ds))

                        mean_g = np.mean(np.asarray(gammas))
                        mean_gs.append(mean_g)
                        std_g = np.std(np.asarray(gammas))
                        std_gs.append(std_g)

                        ax7.scatter(r, mean_g, color=cmap(float(r) / float(max(radii))), marker='o')
                        ax7.errorbar(r, mean_g, yerr=std_g, ecolor=cmap(float(r) / float(max(radii))),
                                     elinewidth=2)

                        axes = [ax4, ax5, ax6]
                        titles = ['$u_x$', '$u_y$', r'$u_\theta$']
                        for ax, text in zip(axes, titles):
                            ax.set_title(text)
                            ax.set_xlim([0, 2 * np.pi])
                            ax.set_ylim([-ux_limit, ux_limit])
                            ax.set_xticks((0, np.pi, 2 * np.pi))
                            ax.set_xticklabels(('$0$', '$\pi$', '$2\pi$'))

                        # STORE ROBUST AND WEIGHTED AVERAGE CIRCULATION DATA
                        robust_g = mean_gs[np.argmin(np.asarray(std_gs))]
                        robust_r = radii[np.argmin(np.asarray(std_gs))]
                        weighted_avg = weighted_mean(mean_gs, std_gs)
                        weighted_avg_std = weighted_mean_std(std_gs)

                        ax7.set_xlabel('countour radius $(mm)$')
                        ax7.set_ylabel('circulation $(mm^2/s)$')
                        ax7.set_title('time: %.4f s' % (f / rate))
                        ax7.set_xlim([0, np.max(radii) + radii_diff])

                        # STORE CIRCULATION DATA IN JSON FORMAT AND SAVE PLOT
                        circulation_data = {'mean_gamma': list(mean_gs),
                                            'std_gamma': list(std_gs),
                                            'radii': list(radii),
                                            'weighted_avg': weighted_avg,
                                            'weighted_avg_std': weighted_avg_std}


                    print 'Circulation (weighted avg) in mm2/s: ' + str(weighted_avg)

                    # Show results on plot
                    gammaavg = np.mean(mean_gs[-5:])
                    gammastd = np.mean(std_gs[-5:])
                    gammaplusstd = [mean_gs[i] + std_gs[i] for i in range(len(mean_gs))]
                    gammaminusstd = [mean_gs[i] - std_gs[i] for i in range(len(mean_gs))]
                    ybottom, ytop = ax7.get_ylim()
                    textposystep = np.abs(ytop-ybottom) / 10.

                    ax7.set_ylim([np.min(gammaminusstd), np.max(gammaplusstd)])
                    text = 'highest $\Gamma_{avg}$: ' + str(np.max(mean_gs)) + ' $mm^2/s$'
                    ax7.text(radii[-int(0.4 * sample_pts)], ybottom + textposystep * 4, text, fontsize=12)
                    text = 'average of last 5 values: ' + str(gammaavg) + ' $mm^2/s$'
                    ax7.text(radii[-int(0.4 * sample_pts)], ybottom + textposystep * 3, text, fontsize=12)
                    text = 'average of last 5 std : ' + str(gammastd) + ' $mm^2/s$'
                    ax7.text(radii[-int(0.4 * sample_pts)], ybottom + textposystep * 2, text, fontsize=12)

                    # Save data in json format
                    circulation_data_name = 'circulation_%06d_domain%d.json' % (f,domain_num)
                    circulation_data_file = os.path.join(circulation_dir, circulation_data_name)
                    with open(circulation_data_file, 'w') as fyle:
                        json.dump(circulation_data, fyle, sort_keys=True, indent=1, separators=(',', ': '))
                        fyle.close()
                    # Save a plot in png
                    fig_name = 'circulation_%06d_domain%d.png' % (f, domain_num)
                    fig_file = os.path.join(circulation_dir, fig_name)
                    plt.savefig(fig_file)
                    print 'Saved...' + fig_file

                    #plt.show()
                    plt.close()



                    # Refer these lists to lists stored in the data_dict  (NOTICE THAT THEY ARE NOT BEING COPIED!)
                    trForGammar = data_dict["domain{0}".format(domain_num)]["trForGammarPos"]
                    trForVr = data_dict["domain{0}".format(domain_num)]["trForVrPos"]
                    trForDr = data_dict["domain{0}".format(domain_num)]['trForDr']
                    gammar = data_dict["domain{0}".format(domain_num)]["gammarPos"]
                    gammar_err = data_dict["domain{0}".format(domain_num)]["gammarPos_err"]
                    cxmaxlist = data_dict["domain{0}".format(domain_num)]["cxmaxlist"]
                    cymaxlist = data_dict["domain{0}".format(domain_num)]["cymaxlist"]
                    cxminlist = data_dict["domain{0}".format(domain_num)]["cxminlist"]
                    cyminlist = data_dict["domain{0}".format(domain_num)]["cyminlist"]
                    vr = data_dict["domain{0}".format(domain_num)]['vrPos']
                    dr = data_dict["domain{0}".format(domain_num)]['dr']

                    ### Core with Positive Vorticity
                    # Time array for Ciruclation
                    trForGammar.append(f / float(rate))
                    # Append a maximum circulation value
                    gammar_max_ind, gammar_max = fa.find_max(mean_gs)
                    gammar.append(gammar_max)
                    gammar_err.append(std_gs[gammar_max_ind])


                    # Calculate ring velocity
                    cxmaxlist.append(cx_max_dict["domain{0}".format(domain_num)])
                    cymaxlist.append(cy_max_dict["domain{0}".format(domain_num)])
                    cxminlist.append(cx_min_dict["domain{0}".format(domain_num)])
                    cyminlist.append(cy_min_dict["domain{0}".format(domain_num)])
                    print '!!!!!!!!!!!!!!'
                    print cx_max_dict["domain{0}".format(domain_num)]
                    print cxmaxlist
                    print '!!!!!!!!!!!!!!'

                    counter = counter_dict["domain{0}Pos".format(domain_num)]
                    if counter % vrtimestep == 0 and len(cxmaxlist) > vrtimestep:
                        trForVr.append(f / float(rate))
                        print trForVr[-1]
                        if len(trForVr) > 1:
                            # Calculate ring velocity
                            vr.append(compute_dist(cxmaxlist[counter], cymaxlist[counter], cxmaxlist[counter-vrtimestep], cymaxlist[counter-vrtimestep])
                                      / (trForVr[counter/vrtimestep-1]-trForVr[counter/vrtimestep-2]))
                            print 'Ring velocity (Pos): %.2f, %d, %d' % (vr[-1], f, domain_num)
                    # Update counter
                    counter_dict["domain{0}Pos".format(domain_num)] = counter_dict["domain{0}Pos".format(domain_num)] + 1

                    # Calculate ring diameter
                    try:
                        dri = compute_dist(cx_max_dict["domain{0}".format(domain_num)], cy_max_dict["domain{0}".format(domain_num)],
                                          cx_min_dict["domain{0}".format(domain_num)], cy_min_dict["domain{0}".format(domain_num)])
                        # Update diameter and time arrays
                        trForDr.append(f/float(rate))
                        dr.append(dri)
                        print 'Diameter: %.2f, %d, %d' % (dri, f, domain_num)
                    except IndexError:
                        print 'Vortex ring core with negative vorticity was not detected!'
                        continue


                    ### Core with Negative Vorticity
                    # Compute circulation
                    mean_gs = []
                    std_gs = []
                    for r in radii:
                        path_x, path_y = r * np.cos(phi) + cxmin, r * np.sin(phi) + cymax
                        iux_p = ndimage.map_coordinates(iuxgrid, (path_y / __yint__, path_x / __xint__), order=1)
                        iuy_p = ndimage.map_coordinates(iuygrid, (path_y / __yint__, path_x / __xint__), order=1)

                        # CALCULATE AND PLOT CIRCULATIONS AND STATISTICS
                        gammas = []
                        cm_shift_list = np.linspace(-cm_shift * scale, cm_shift * scale, num=10)
                        for off_i in cm_shift_list:
                            for off_j in cm_shift_list:
                                ds = 2 * np.pi * r / float(NP)
                                path_x, path_y = r * np.cos(phi) + cxmin + off_i, r * np.sin(phi) + cymin + off_j
                                iux_p = ndimage.map_coordinates(iuxgrid, (path_y / __yint__, path_x / __xint__),
                                                                order=1)
                                iuy_p = ndimage.map_coordinates(iuygrid, (path_y / __yint__, path_x / __xint__),
                                                                order=1)
                                gammas.append(sum((-iux_p * np.sin(phi) + iuy_p * np.cos(phi)) * ds))

                        mean_g = np.mean(np.asarray(gammas))
                        mean_gs.append(mean_g)
                        std_g = np.std(np.asarray(gammas))
                        std_gs.append(std_g)

                        # STORE ROBUST AND WEIGHTED AVERAGE CIRCULATION DATA
                        robust_g = mean_gs[np.argmin(np.asarray(std_gs))]
                        robust_r = radii[np.argmin(np.asarray(std_gs))]
                        weighted_avg = weighted_mean(mean_gs, std_gs)
                        weighted_avg_std = weighted_mean_std(std_gs)

                        # # STORE CIRCULATION DATA IN JSON FORMAT AND SAVE PLOT
                        # circulation_data_neg = {'mean_gamma': list(mean_gs),
                        #                     'std_gamma': list(std_gs),
                        #                     'radii': list(radii),
                        #                     'weighted_avg': weighted_avg,
                        #                     'weighted_avg_std': weighted_avg_std}

                    # Refer these lists to lists stored in the data_dict  (NOTICE THAT THEY ARE NOT BEING COPIED!)
                    trForGammar = data_dict["domain{0}".format(domain_num)]["trForGammarNeg"]
                    trForVr = data_dict["domain{0}".format(domain_num)]["trForVrNeg"]
                    gammar = data_dict["domain{0}".format(domain_num)]["gammarNeg"]
                    gammar_err = data_dict["domain{0}".format(domain_num)]["gammarNeg_err"]
                    vr = data_dict["domain{0}".format(domain_num)]['vrNeg']

                    # Time array for Ciruclation
                    trForGammar.append(f / float(rate))
                    # Append a minimum circulation value
                    gammar_min_ind, gammar_min = fa.find_min(mean_gs)
                    gammar.append(gammar_min)
                    gammar_err.append(std_gs[gammar_min_ind])


                    # Calculate ring velocity
                    counter = counter_dict["domain{0}Neg".format(domain_num)]
                    if counter % vrtimestep == 0 and len(cxminlist)>vrtimestep:
                        trForVr.append(f / float(rate))
                        if len(trForVr) > 1:
                            # Calculate ring velocity
                            vr.append(compute_dist(cxminlist[counter], cyminlist[counter], cxminlist[counter-vrtimestep], cyminlist[counter-vrtimestep])
                                      / (trForVr[counter/vrtimestep-1]-trForVr[counter/vrtimestep-2]))
                            print 'Ring velocity (Neg): %.2f, %d, %d' % (vr[-1], f, domain_num)

                    # Update counter
                    counter_dict["domain{0}Neg".format(domain_num)] = counter_dict["domain{0}Neg".format(domain_num)] + 1


                    print '------------------------------'


        print '------------------------------'
        print 'PLOTTING TIME-EVOLUTION'
        # Convenction for plotting
        #marker = ['v', '^', 's', 'o'] # makers corresponding to domains
        fillstyle = ['full', 'none'] #Positive core: fill, Negative core: no fill


        for domain_num in range(1, 5):
            trForGammarPos = data_dict["domain{0}".format(domain_num)]["trForGammarPos"]
            trForGammarNeg = data_dict["domain{0}".format(domain_num)]["trForGammarNeg"]
            trForVrPos = data_dict["domain{0}".format(domain_num)]["trForVrPos"]
            trForVrNeg = data_dict["domain{0}".format(domain_num)]["trForVrNeg"]
            trForDr = data_dict["domain{0}".format(domain_num)]['trForDr']
            gammarPos = data_dict["domain{0}".format(domain_num)]["gammarPos"]
            gammarPos_err = data_dict["domain{0}".format(domain_num)]["gammarPos_err"]
            gammarNeg = np.abs(data_dict["domain{0}".format(domain_num)]["gammarNeg"]) # take absolute values of negative circulation values
            gammarNeg_err = data_dict["domain{0}".format(domain_num)]["gammarNeg_err"]
            cxmaxlist = data_dict["domain{0}".format(domain_num)]["cxmaxlist"]
            cymaxlist = data_dict["domain{0}".format(domain_num)]["cymaxlist"]
            cxminlist = data_dict["domain{0}".format(domain_num)]["cxminlist"]
            cyminlist = data_dict["domain{0}".format(domain_num)]["cyminlist"]
            vrPos = data_dict["domain{0}".format(domain_num)]['vrPos']
            vrNeg = data_dict["domain{0}".format(domain_num)]['vrNeg']
            dr = data_dict["domain{0}".format(domain_num)]['dr']

            labels = ['top left', 'bottom left', 'top right', 'bottom right']
            labelsPos = ['top left (+)', 'bottom left (+)', 'top right (+)', 'bottom right (+)']
            labelsNeg = ['top left (-)', 'bottom left (-)', 'top right (-)', 'bottom right (-)']

            # Drop the last element b/c trForVr has elements one less than vrPos/Neg
            trForVrPos, trForVrNeg = trForVrPos[:-1], trForVrNeg[:-1]
            print trForDr, dr
            #Clean data about circulation, ring diameter, ring velocity
            if not trForGammarPos ==[]:
                # trForGammarPos, gammarPos, gammarPos_err = process.clean_multi_dim_array_trio_using_median(trForGammarPos, gammarPos, gammarPos_err, cutoffratio=0.6, mode='less')
                # trForGammarPos, gammarPos, gammarPos_err = process.clean_multi_dim_array_trio_using_median(trForGammarPos, gammarPos, gammarPos_err, cutoffratio=1.3, mode='greater')
                gammarPos_avg = np.mean(gammarPos)
                gammarPos_std = np.std(gammarPos)
            else:
                gammarPos_avg, gammarPos_std = np.nan, np.nan
            if not trForGammarNeg == []:
                # trForGammarNeg, gammarNeg, gammarNeg_err = process.clean_multi_dim_array_trio_using_median(trForGammarNeg, gammarNeg, gammarNeg_err, cutoffratio=0.6, mode='less')
                # trForGammarNeg, gammarNeg, gammarNeg_err = process.clean_multi_dim_array_trio_using_median(trForGammarNeg, gammarNeg, gammarNeg_err, cutoffratio=1.3, mode='greater')
                gammarNeg_avg = np.mean(gammarNeg)
                gammarNeg_std = np.std(gammarNeg)
                gammarNeg_std = np.std(gammarNeg)
            else:
                gammarNeg_avg, gammarNeg_std = np.nan, np.nan
            if not trForVrPos == []:
                trForVrPos, vrPos = process.clean_multi_dim_array_pair_using_cutoff(trForVrPos, vrPos, cutoff=1300., mode='greater')
                trForVrPos, vrPos = process.clean_multi_dim_array_pair_using_median(trForVrPos, vrPos, cutoffratio=0.6, mode='less')
                trForVrPos, vrPos = process.clean_multi_dim_array_pair_using_median(trForVrPos, vrPos, cutoffratio=1.3, mode='greater')
                vrPos_avg = np.mean(vrPos)
                vrPos_std = np.std(vrPos)
            else:
                vrPos_avg, vrPos_std = np.nan, np.nan
            if not trForVrNeg == []:
                trForVrNeg, vrNeg = process.clean_multi_dim_array_pair_using_cutoff(trForVrNeg, vrNeg, cutoff=1300., mode='greater')
                trForVrNeg, vrNeg = process.clean_multi_dim_array_pair_using_median(trForVrNeg, vrNeg, cutoffratio=0.6, mode='less')
                trForVrNeg, vrNeg = process.clean_multi_dim_array_pair_using_median(trForVrNeg, vrNeg, cutoffratio=1.3, mode='greater')
                vrNeg_avg = np.mean(vrNeg)
                vrNeg_std = np.std(vrNeg)
            else:
                vrNeg_avg, vrNeg_std = np.nan, np.nan
            if not trForDr == []:
                trForDr, dr = process.clean_multi_dim_array_pair_using_cutoff(trForDr, dr, cutoff=4., mode='less')
                trForDr, dr = process.clean_multi_dim_array_pair_using_cutoff(trForDr, dr, cutoff=50., mode='greater')
                trForDr, dr = process.clean_multi_dim_array_pair_using_median(trForDr, dr, cutoffratio=0.6, mode='less')
                trForDr, dr = process.clean_multi_dim_array_pair_using_median(trForDr, dr, cutoffratio=1.3, mode='greater')
                dr_avg = np.mean(dr)
                dr_std = np.std(dr)
                print trForDr, dr
            else:
                dr_avg, dr_std = np.nan, np.nan

            # print gammarPos_avg,gammarNeg_avg,vrPos_avg,vrNeg_avg,dr_avg

            # gammarPos_avg = np.mean(gammarPos)
            # gammarNeg_std = np.std(gammarNeg)
            # vrPos_avg = np.mean(vrPos)
            # vrPos_std = np.std(vrPos)
            # vrNeg_avg = np.mean(vrNeg)
            # vrNeg_std = np.std(vrNeg)


            # #Error processing in case gammar etc. are empty arrays
            # if len(trForGammarPos)==0 or len(trForVrPos)==0 or len(trForDr)==0:
            #     fig8 = plt.figure()
            #     ax = fig8.add_axes([0, 0, 1, 1])
            #     left, width = .25, .5
            #     bottom, height = .25, .5
            #     right = left + width
            #     top = bottom + height
            #     ax.text(0.5 * (left + right), 0.5 * (bottom + top), 'No vortex ring was detected!',
            #             horizontalalignment='center',
            #             verticalalignment='center',
            #             fontsize=20, color='red',
            #             transform=ax.transAxes)
            #     savedir = resultsdir + '/time_evolution/'
            #     filename = 'No_vortex_ring_detected'
            #     graph.save(savedir + filename, ext='png', close=True)
            #     continue

            # Plot circulation, ring velocity, and diameter
            # CIRCULATION PLOT (TIME EVOLUTION)
            if not trForGammarPos == []:
                fig8, ax8 = graph.errorbar(trForGammarPos, gammarPos, yerr=gammarPos_err, marker='o', color=colors[domain_num-1], label=labelsPos[domain_num-1],
                                           alpha=0.9, fillstyle=fillstyle[0], fignum=2, subplot=131, figsize=(20, 5))
            if not trForGammarNeg == []:
                fig8, ax8 = graph.errorbar(trForGammarNeg, gammarNeg, yerr=gammarNeg_err, marker='o', color=colors[domain_num-1], label=labelsNeg[domain_num-1],
                                           alpha=0.9, fillstyle=fillstyle[1], fignum=2, subplot=131, figsize=(20, 5))
            if not trForGammarPos == [] and not trForGammarNeg == []:
                graph.labelaxes(ax8, 'Time ($s$)', 'Circulation ($mm^2/s$)')
                if not math.isnan(max(gammarPos_avg, gammarNeg_avg)):
                    gammar_lim = max([max(gammarPos_avg, gammarNeg_avg)*1.3, np.max(np.concatenate((gammarPos, gammarNeg))), gammar_lim])
                    graph.setaxes(ax8, 0, time[-1], 0, gammar_lim)
                    # if not trForGammarPos == []:
                    #     text = 'Average $\Gamma$ (+): %.1f' % gammarPos_avg + '$mm^2/s$'
                    #     graph.addtext(ax8, x=(time[-1])/10., y=gammarPos_avg * 1.3 / 8. * 4., text=text)
                    #     text = 'Std. (+): %.1f' % gammarPos_std + '$mm^2/s$'
                    #     graph.addtext(ax8, x=(time[-1])/10., y=gammarNeg_std * 1.3 / 8. * 3., text=text)
                    # if not trForGammarNeg == []:
                    #     text = 'Average $\Gamma$ (-): %.1f' % gammarNeg_avg + '$mm^2/s$'
                    #     graph.addtext(ax8, x=(time[-1]) / 10., y=gammarNeg_avg * 1.3 / 8. * 2., text=text)
                    #     text = 'Std. (-): %.1f' % gammarNeg_std + '$mm^2/s$'
                    #     graph.addtext(ax8, x=(time[-1]) / 10., y=gammarNeg_std * 1.3 / 8. * 1., text=text)
            else:
                fig8, ax8 = graph.set_fig(fignum=2, subplot=131, figsize=(20, 5))
                graph.labelaxes(ax8, 'Time ($s$)', 'Circulation ($mm^2/s$)')


            # RING VELOCITY PLOT (TIME EVOLUTION)
            if not trForVrPos == []:
                fig9, ax9 = graph.scatter(trForVrPos, vrPos,  marker='o', color=colors[domain_num-1],fillstyle=fillstyle[0], label=labelsPos[domain_num-1],
                                          alpha=0.9, fignum=2, subplot=132, figsize=(20, 5))
            if not trForVrNeg == []:
                fig9, ax9 = graph.scatter(trForVrNeg, vrNeg,  marker='o', color=colors[domain_num-1], fillstyle=fillstyle[1], label=labelsNeg[domain_num-1],
                                          alpha=0.9, fignum=2, subplot=132, figsize=(20, 5))
            if not trForVrPos == [] and not trForVrNeg == []:
                graph.labelaxes(ax9, 'Time ($s$)', 'Ring velocity ($mm/s$)')
                print vrPos, vrNeg
                print trForVrPos, trForVrNeg
                if not math.isnan(max(vrPos_avg, vrNeg_avg)):
                    vr_lim = max([max(vrPos_avg, vrNeg_avg)*1.3,  np.max((np.concatenate((vrPos, vrNeg)))), vr_lim])
                    graph.setaxes(ax9, 0, time[-1], 0, vr_lim)
                    # Add text (ring velocity and std)
                    # if not trForVrPos == []:
                    #     text = 'Average $v_r$ (+): %.1f' % vrPos_avg + '$mm/s$'
                    #     graph.addtext(ax9, x=(time[-1])/10., y=vrPos_avg * 1.3 / 8. * 4, text=text)
                    #     text = 'Std. (-): %.1f' % vrPos_std + '$mm/s$'
                    #     graph.addtext(ax9, x=(time[-1]) / 10., y=vrPos_std * 1.3 / 8. * 3, text=text)
                    # if not trForVrNeg == []:
                    #     text = 'Average $v_r$ (+): %.1f' % vrNeg_avg + '$mm/s$'
                    #     graph.addtext(ax9, x=(time[-1]) / 10., y=vrNeg_avg * 1.3 / 8 * 2, text=text)
                    #     text = 'Std. (-): %.1f' % vrNeg_std + '$mm/s$'
                    #     graph.addtext(ax9, x=(time[-1]) / 10., y=vrNeg_std * 1.3 / 8. * 1, text=text)
            else:
                # If there is no data, make an empty figure
                fig9, ax9 = graph.set_fig(fignum=2, subplot=132, figsize=(20, 5))
                graph.labelaxes(ax9, 'Time ($s$)', 'Ring velocity ($mm/s$)')

            print trForDr, len(trForDr)
            #if not trForDr == []: # For some reason, this line fails... WHY? Use the next line instead- takumi 4/14/18
            if not len(trForDr) == 0:
                print 'here'
                print trForDr
                fig10, ax10 = graph.scatter(trForDr, dr, marker='o', color=colors[domain_num-1], fillstyle=fillstyle[0], label=labels[domain_num-1],
                                            alpha=0.9, fignum=2, subplot=133, figsize=(20, 5))
                graph.labelaxes(ax10, 'Time ($s$)', 'Ring diameter ($mm$)')
                print dr_avg*1.3, np.max(dr), dr_lim, domain_num
                dr_lim = max(dr_avg*1.3, np.max(dr), dr_lim)
                graph.setaxes(ax10, 0, time[-1], 0, dr_lim)
                # text = 'Average $D$: %.1f' % dr_avg + '$mm$'
                # graph.addtext(ax10, x=(time[-1])/10., y=dr_avg*1.3/4.*2, text=text)
                # text = 'Std.: %.1f' % dr_std + '$mm$'
                # graph.addtext(ax10, x=(time[-1])/10., y=dr_avg * 1.3 / 4., text=text)
            else:
                fig10, ax10 = graph.set_fig(fignum=2, subplot=133, figsize=(20, 5))
                graph.labelaxes(ax10, 'Time ($s$)', 'Ring diameter ($mm$)')
        ax8.legend()
        ax9.legend()
        ax10.legend()

        savedir = resultsdir + '/time_evolution/'
        filename = 'circulation_vring_diameter'
        graph.save(savedir+filename, ext='png', close=True)

        #     # Save data in json format
        #     time_evolution_data = {'trForGammarPos': trForGammarPos.tolist(),
        #                            'gammarPos': gammarPos.tolist(),
        #                            'trForGammarNeg': trForGammarNeg.tolist(),
        #                            'gammarNeg': gammarNeg.tolist(),
        #                            'trForVrPos': trForVrPos.tolist(),
        #                            'vrPos': vrPos.tolist(),
        #                            'trForVrNeg': trForVrNeg.tolist(),
        #                            'vrNeg': vrNeg.tolist(),
        #                            'trForDrPos': trForDr.tolist(),
        #                            'dr': dr.tolist()
        #                            }
        #
        # time_evolution_data_name = 'time_evolution_data.json'
        # time_evolution_data_path = savedir + 'time_evolution_data.json'
        # with open(time_evolution_data_path, 'w') as fyle:
        #     json.dump(time_evolution_data, fyle, sort_keys=True, indent=1, separators=(',', ': '))
        #     fyle.close()

        import library.tools.rw_data as rw

        time_evolution_data_path = savedir + 'time_evolution_data_four_rings.json'
        rw.write_json(time_evolution_data_path, data_dict)
        print '---------------'


    print 'Done'