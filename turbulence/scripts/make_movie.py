#!/usr/bin/env python
"""
Finds up to four vortex rings and compute circulation, vring, and diameter of each ring
- Computes and plots circulation at every args.plot_spacing frames
- Computes and plots circulation velocity and radius of vortex rings over time

... Note that PIVLab outputs x,y in pixels!
"""
import argparse
import os
import sys
import cine
import json
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import matplotlib.path as path
import pickle
from matplotlib import cm
from matplotlib.widgets import RectangleSelector
from scipy import ndimage, interpolate
from mpl_toolkits.axes_grid1 import make_axes_locatable
from scipy import ndimage
# import ilpm.cine as cine
import numpy as np
import math

from scipy.interpolate import interp1d
from scipy.ndimage import map_coordinates

import library.tools.browse as browse
import library.tools.process_data as process
import library.display.graph as graph
import library.basics.formatstring as fs
import library.basics.formatarray as fa
import library.basics.roipoly as roipoly


cmap = cm.spectral
cmap2 = cm.bwr
colorcycle = graph.get_default_color_cycle()

cx_lim = 100
cy_lim = 100

# Extract a fraction of vorticity data around a position of maximum/minimum vorticity
# Unless the cores are near the edge, it gets grids with dimension (nx_frac * 2 + 1, ny_frac * 2 + 1)
nx_frac, ny_frac = 7, 7

# thresholds
gamma_thd = 1000.0 # in mm^2/s
d_thd = 10 # in mm;  threshold to stop the circulation computation
d_thd_opp_core = 5 # in mm; threshold to alert if the detected cores are too close to each other

# cutoff values for cleaning raw data
cutoffu = 5.  #px/frame
cutoffomega = 0.2 #/frame

# new grid spacing in mm
__xint__, __yint__ = 1., 1.

# ratios used to divide a window into quadrants (See a figure below)
rx, ry = 0.5, 0.5

# Frequencey of computing ring velocity
vrtimestep = 1  # compute vr every n steps

#
global proceed, use_roi, redo, rec_x_ini, rec_y_ini, rec_x_fin, rec_y_fin, is_core_in_window, terminate
core_check_thd = 0.1
proceed = True
use_roi = False
redo = True
is_core_in_window = True
terminate = False


def load_matlab_data(datapath):
    """Reads data from .txt files generated by PIVlab and places them into numpy arrays

    Parameters
    ----------
    data_loc : str
        The directory containing .txt files generated from PIVlab

    Returns
    -------
    x, y, ux, uy, omega array (floats)
        coordinates, velocity components, and vorticity calculated by PIVlab
    """
    file = open(datapath)
    x, y, ux, uy, omega = [], [], [], [], []
    for i, line in enumerate(file):
        if i < 3:
            continue
        for j, val in enumerate(line.split(',')):
            if j == 0:
                x.append(int(val))
            elif j == 1:
                y.append(int(val))
            elif j == 2:
                ux.append(float(val))
            elif j == 3:
                uy.append(float(val))  # Note that there is a minus sign due to the default coordinate system in PIVLab.
            elif j == 4:
                omega.append(float(val))

    if j == 4:
        x, y, ux, uy, omega = map(lambda z: np.asarray(z), [x, y, ux, uy, omega])
        return x, y, ux, uy, omega
    elif j == 3:
        x, y, ux, uy = map(lambda z: np.asarray(z), [x, y, ux, uy])
        return x, y, ux, uy

def interp_flow_component(x, y, ux, xint=__xint__, yint=__yint__, method='linear'):
    """
    Interpolate x,y, and data (ux) into x_new which has interval of __xint__
    Parameters
    ----------
    x
    y
    ux
    xint
    yint
    method

    Returns
    -------
    Xnew, Ynew: x and y coordinates of a grid
    datanew : 2d numpy array

    """
    uxindicies = [(xx, yy) for xx, yy in zip(x, y)]
    # grid_ind0, grid_ind1 = mgrid[0:imsize[0], 0:imsize[1]]
    # griddata = interpolate.griddata(uxindicies, ux, (grid_ind0, grid_ind1), method=method, fill_value=0.)
    xmin, xmax, ymin, ymax = np.min(x), np.max(x), np.min(y), np.max(y)

    xnew, ynew = np.arange(xmin, xmax + xint, xint), np.arange(ymin, ymax + yint, yint)
    Xnew, Ynew = np.meshgrid(xnew, ynew)
    griddata = interpolate.griddata(uxindicies, ux, (Xnew, Ynew), method=method, fill_value=0.)

    return Xnew, Ynew, griddata

def interp_for_pcolormesh(x, y, data, xint=__xint__, yint=__yint__, method='cubic'):
    """
    (PIVLab only)
    Takes 1d arrays for x, y, data, and generate a grid, interpolate data,
    and give back grids (2d arrays generated by np.meshgrid) and interpolated data
    One can immediately generate a heatmap by using pcolormesh(Xnew, Ynew, datanew)

    Parameters
    ----------
    x 1d array
    y 1d array
    data 1d array
    xint interval of new x, float
    yint interval of new x, float
    method method of interpolation, str
           Refer to interpolate.interp2d for available options

    Returns
    -------
    Xnew 2d array generated by np.meshgrid
    Ynew 2d array generated by np.meshgrid
    datanew 2d array

    """
    f = interpolate.interp2d(x, y, data, kind=method)

    # make a meshgrid
    xnew, ynew = np.arange(x[0], x[-1] + xint, xint), np.arange(y[0], y[-1] + yint, yint)
    Xnew, Ynew = np.meshgrid(xnew, ynew)
    # interpolate using scipy.interpolate.inter2d
    datanew = f(xnew, ynew)

    return Xnew, Ynew, datanew

def colorbar(mappable, location='right'):
    ax = mappable.axes
    fig = ax.figure
    divider = make_axes_locatable(ax)
    cax = divider.append_axes(location, size='5%', pad=0.05)
    return fig.colorbar(mappable, cax=cax)

def weighted_mean(means, stds):
    """
    Compute weighted arithmetic mean
    Parameters
    ----------
    means : list (floats)
        list of mean values
    stds : list (floats)
        list of standard deviations associated to means

    Returns
    -------
    weighted_mean : float
    """
    return sum(np.asarray(means * (1. / np.asarray(stds)))) / sum(1. / np.asarray(stds))

def weighted_mean_std(stds):
    """
    Compute the uncertainty for a weighted mean
    Parameters
    ----------
    stds : list (floats)
        list of standard deviations associated to means

    Returns
    -------
    weighted_mean_std : float
    """
    return np.sqrt(1. / sum(1. / np.asarray(stds)))

def find_center_of_arr2d(arr):
    """
    Returns a center of 2d array
    For example, if the array contains mass distribution, then this returns the center of mass.
    Parameters
    ----------
    arr

    Returns
    -------

    """
    arr = np.array(arr)
    cx, cy = 0, 0
    for i in range(arr.shape[0]):
        for j in range(arr.shape[1]):
            cx = i * arr[i][j]
            cy = j * arr[i][j]
    cx, cy = cx / arr.sum(), cy / arr.sum()
    return cx, cy

def compute_dist(x1, y1, x2, y2):
    """Compute distance between two points (x1,y1) and (x2,y2)"""
    return float(np.sqrt((x1-x2)**2. + (y1-y2)**2.))

def compute_circulation(iuxgrid, iuygrid, cx, cy, radii, phi, cm_shift, scale):
    for r in radii:
        path_x, path_y = r * np.cos(phi) + cx, r * np.sin(phi) + cy
        iux_p = ndimage.map_coordinates(iuxgrid, (path_y / __yint__, path_x / __xint__), order=1)
        iuy_p = ndimage.map_coordinates(iuygrid, (path_y / __yint__, path_x / __xint__), order=1)

        # CALCULATE AND PLOT CIRCULATIONS AND STATISTICS
        gammas = []
        cm_shift_list = np.linspace(-cm_shift * scale, cm_shift * scale, num=10)
        for off_i in cm_shift_list:
            for off_j in cm_shift_list:
                ds = 2 * np.pi * r / float(NP)
                path_x, path_y = r * np.cos(phi) + cx + off_i, r * np.sin(phi) + cy + off_j
                iux_p = ndimage.map_coordinates(iuxgrid, (path_y / __yint__, path_x / __xint__), order=1)
                iuy_p = ndimage.map_coordinates(iuygrid, (path_y / __yint__, path_x / __xint__), order=1)
                gammas.append(sum((-iux_p * np.sin(phi) + iuy_p * np.cos(phi)) * ds))

        mean_g = np.mean(np.asarray(gammas))
        mean_gs.append(mean_g)
        std_g = np.std(np.asarray(gammas))
        std_gs.append(std_g)
    return radii, mean_gs, std_gs

def update_data_dict(dict, key, subkey, data=[]):
    """
    Generate a dictionary that stores effective velocity
    Parameters
    ----------
    dict
    key: span like span5.4
    subkey: commanded velocity, str
    data: effective velocity, float

    Returns
    -------

    """
    if not key in dict:
        dict[key] = {}  # Generate a sub-dictionary
    dict[key][subkey] = data
    return dict

def draw_quadrants(ax, rx, ry):
    """
    Draw two lines to show quadrants
    Parameters
    ----------
    ax
    rx
    ry

    Returns
    -------

    """
    xmin, xmax = ax.get_xlim()
    ymax, ymin = ax.get_ylim()
    width, height = xmax - xmin, ymax - ymin
    ax.axhline(ymin + height * ry)
    ax.axvline(xmin + width * rx)

def make_quadrants(xmin, xmax, ymin, ymax, rx, ry):
    """
    Make quadrants as matplotlib.path objects
    Return a list of quadrants as path objects

    Parameters
    ----------
    ax
    rx
    ry

    Returns
    -------

    """
    width, height = xmax - xmin, ymax - ymin
    # Quadrant 1
    verts1 = [
        (xmin, ymin),
        (xmin + width * rx, ymin),
        (xmin + width * rx, ymin + height * ry),
        (xmin, ymin + height * ry),
        (xmin, ymin)
    ]
    # Quadrant 2
    verts2 = [
        (xmin, ymin + height * ry),
        (xmin + width * rx, ymin + height * ry),
        (xmin + width * rx, ymax),
        (xmin, ymax),
        (xmin, ymin + height * ry)
    ]
    # Quadrant 3
    verts3 = [
        (xmin + width * rx, ymin),
        (xmax, ymin),
        (xmax, ymin + height * ry),
        (xmin + width * rx, ymin + height * ry),
        (xmin + width * rx, ymin)
    ]
    # Quadrant 4
    verts4 = [
        (xmin + width * rx, ymin + height * ry),
        (xmax, ymin + height * ry),
        (xmax, ymax),
        (xmin + width * rx, ymax),
        (xmin + width * rx, ymin + height * ry),
    ]
    codes = [path.Path.MOVETO,
             path.Path.LINETO,
             path.Path.LINETO,
             path.Path.LINETO,
             path.Path.CLOSEPOLY,
             ]
    quad1, quad2, quad3, quad4 = path.Path(verts1, codes), path.Path(verts2, codes), path.Path(verts3, codes), path.Path(verts4, codes)
    quads = [quad1, quad2, quad3, quad4]
    return quads

def get_proper_indices_for_x(a, ncolumns):
    if a < 0:
        return 0
    elif a >= ncolumns:
        return int(ncolumns - 1)
    else:
        return int(a)

def get_proper_indices_for_y(a, nrows):
    if a < 0:
        return 0
    elif a >= nrows:
        return int(nrows - 1)
    else:
        return int(a)

def get_small_grids_around_coord(griddata, xgrid, ygrid, x, y, nx, ny):
    nrows, ncolumns = griddata.shape
    griddata_around_coord = griddata[get_proper_indices_for_y(y - ny, nrows): get_proper_indices_for_y(y + ny, nrows),
                            get_proper_indices_for_x(x - nx, ncolumns): get_proper_indices_for_x(x + nx, ncolumns)]
    xgrid_around_coord = xgrid[get_proper_indices_for_y(y - ny, nrows): get_proper_indices_for_y(y + ny, nrows),
                         get_proper_indices_for_x(x - nx, ncolumns): get_proper_indices_for_x(x + nx, ncolumns)]
    ygrid_around_coord = ygrid[get_proper_indices_for_y(y - ny, nrows): get_proper_indices_for_y(y + ny, nrows),
                         get_proper_indices_for_x(x - nx, ncolumns): get_proper_indices_for_x(x + nx, ncolumns)]
    return xgrid_around_coord, ygrid_around_coord, griddata_around_coord

####
def redefine_rx(event):
    """
    Click a point to redefine rx
    Click outside the image to apply the change
    Parameters
    ----------
    event

    Returns
    -------

    """
    global rx, terminate, roi_bool, polylines, reject, use_roi, redo
    print 'CLICK A POINT TO REDEFINE rx. CLICK OUTSIDE THE PLOT TO CLOSE THE PLOT.'
    xmin, xmax = ax.get_xlim()
    ymax, ymin = ax.get_ylim()
    if event.key == 'd':
        global redo
        print 'Redo core detection!'
        redo = True
        print 'REDO redefine rx: %r' %redo
    elif event.key == 't':
        print 'You pressed %s. Terminating computations after this step...' % event.key
        terminate = True
        fig.canvas.mpl_disconnect(cid)
        plt.close()
    elif event.key == 'r':
        print 'You pressed %s. Draw ROI' % event.key
        use_roi = True
        redo = True
        plt.close()
    elif event.key == 'p':
        print 'You pressed %s. Pass' % event.key
        redo = False
        plt.close()


    if event.xdata is not None and event.ydata is not None:
        print 'redefine_rx: %.2f. %.2f' % (event.xdata, event.ydata)
        plt.axvline(x=event.xdata)
        #fig.canvas.flush_events()
        plt.show()
        rx = (event.xdata - xmin) / xmax
        print 'rx: %.2f' % rx
    else:
        print 'Exitting... rx = %.2f' % rx
        fig.canvas.mpl_disconnect(cid)
        plt.close()

def redefine_ry(event):
    """
    Click a point to redefine ry
    Click outside the image to apply the change
    Parameters
    ----------
    event

    Returns
    -------

    """
    global ry, terminate, roi_bool, polylines, reject, use_roi, redo
    print 'CLICK A POINT TO REDEFINE ry. CLICK OUTSIDE THE PLOT TO CLOSE THE PLOT.'
    xmin, xmax = ax.get_xlim()
    ymax, ymin = ax.get_ylim()
    if event.key == 'd':
        global redo
        print 'Redo core detection!'
        redo = True
        print 'REDO redefine ry: %r' %redo
    elif event.key == 't':
        print 'You pressed %s. Terminating computations after this step...' % event.key
        terminate = True
        fig.canvas.mpl_disconnect(cid)
        plt.close()
    elif event.key == 'r':
        print 'You pressed %s. Draw ROI' % event.key
        use_roi = True
        redo = True
        plt.close()
    elif event.key == 'p':
        print 'You pressed %s. Pass' % event.key
        redo = False
        plt.close()


    if event.xdata is not None and event.ydata is not None:
        print 'redefine_ry: %.2f. %.2f' % (event.xdata, event.ydata)
        plt.axhline(y=event.ydata)
        #fig.canvas.flush_events()
        plt.show()
        ry = (event.ydata - ymin) / ymax
        print 'ry: %.2f' % ry
    else:
        print 'Exitting... ry = %.2f' % ry
        fig.canvas.mpl_disconnect(cid)
        plt.close()

def draw_trajectory(data_dict, show=True):
    fig3, ax31 = graph.set_fig(fignum=3, subplot=111, figsize=(16, 10))
    for domain_num in range(1, 5):
        # these are lists of core positions
        cxmax = data_dict["domain{0}".format(domain_num)]["cxmaxlist"]
        cymax = data_dict["domain{0}".format(domain_num)]["cymaxlist"]
        cxmin = data_dict["domain{0}".format(domain_num)]["cxminlist"]
        cymin = data_dict["domain{0}".format(domain_num)]["cyminlist"]

        core_positions = [[cxmax, cymax], [cxmin, cymin]]

        # For plot
        marker = ['v', '^', 's', 'o']  # makers corresponding to domains
        fillstyle = ['full', 'none']  # Positive core: fill, Negative core: no fill
        colors = graph.get_first_n_colors_from_color_cycle(4)

        for j, core_position in enumerate(core_positions):
            print core_position
            cx, cy = core_position[0], core_position[1]
            ax31.plot(cx, cy, color=colors[domain_num - 1], marker=marker[domain_num - 1],
                      alpha=0.7, fillstyle=fillstyle[j])
            graph.setaxes(ax31, 0, imsize[1] * scale, 0, imsize[0] * scale)
            graph.labelaxes(ax31, 'x [mm]', 'y [mm]')
            ax31.invert_yaxis()
        if show:
            graph.show()

def initialize_good_core_bools(data_dict):
    for domain_num in range(1,5):
        data_dict["domain{0}".format(domain_num)]['good_corePos'] = False
        data_dict["domain{0}".format(domain_num)]['good_coreNeg'] = False
    return data_dict


def line_select_callback(eclick, erelease):
    'eclick and erelease are the press and release events'
    global rec_x_ini, rec_y_ini, rec_x_fin, rec_y_fin
    rec_x_ini, rec_y_ini = eclick.xdata, eclick.ydata
    rec_x_fin, rec_y_fin = erelease.xdata, erelease.ydata
    print("(%3.2f, %3.2f) --> (%3.2f, %3.2f)" % (rec_x_ini, rec_y_ini, rec_x_fin, rec_y_fin))
    print(" The button you used were: %s %s" % (eclick.button, erelease.button))

def toggle_selector(event):
    global rec_x_ini, rec_y_ini, rec_x_fin, rec_y_fin, is_core_in_window, use_roi
    print('Key %s pressed.' % event.key)
    if event.key in ['Q', 'q'] and toggle_selector.RS.active:
        print(' RectangleSelector deactivated.')
        toggle_selector.RS.set_active(False)
    if event.key in ['A', 'a'] and not toggle_selector.RS.active:
        print(' RectangleSelector activated.')
        toggle_selector.RS.set_active(True)
    if event.key == 'c':
        plt.close()
    if event.key == 'u':
        print 'Escape from the ROI mode'
        use_roi = False

    if event.key == 'n':
        rec_x_ini, rec_y_ini, rec_x_fin, rec_y_fin = np.nan, np.nan, np.nan, np.nan
        is_core_in_window = False
        print('The core is not in the window!')
        plt.close()
    # In case n was pressed by mistake, the following line reverses the effect
    if event.key == 'm':
        is_core_in_window = True
        print('The core is in the window!')


def check_cores(event):
    """
    Decide whether you would like to accept the detected cores (press p for pass)
    or redo the core detection in the ROI mode (press n for not good)
    Parameters
    ----------
    event

    Returns
    -------

    """
    global use_roi, redo, terminate
    print 'Press p if all cores are good, and press r to redo core detection using ROI'
    print 'You pressed %s. ' % event.key
    if event.key == 'p':
        print 'All cores look good. Keep processing'
        redo = False
        fig.canvas.mpl_disconnect(cid)
        plt.close()
    if event.key == 'r':
        print 'Redo core detection using ROI'
        use_roi = True
        redo = True
        fig.canvas.mpl_disconnect(cid)
        plt.close()
    if event.key == 't':
        print 'Terminate.'
        terminate = True
        redo = False
        fig.canvas.mpl_disconnect(cid)
        plt.close()


if __name__ == '__main__':
    """
    Pass a absolute path of the cine files through '-input' e.g. -input '/absolute/path/to/cineDir/*.cine'
    """
    parser = argparse.ArgumentParser(description='')
    # Parameter to specify a data location
    parser.add_argument('-input', metavar='input', type=str, nargs='*', default=None, help='e.g. -input /absolute/path/to/cineDir/*.cine')
    # Parameters to specify the region in which the analysis is conducted
    parser.add_argument('-start', dest='start', type=int, default=0, help='Frame number to start the analysis')
    parser.add_argument('-stop', dest='stop', type=int, default=0, help='Frame number to end the analysis')
    parser.add_argument('-skip', dest='skip', type=int, default=10, help='Use every "skip" frames for analysis. default=10')
    parser.add_argument('-fileskip', dest='fileskip', type=int, default=0,
                        help='number of cines to skip in the cine list')
    parser.add_argument('-process_all', dest='process_all', action='store_true', default=False,
                        help='If added, compute circulation for ALL frames in cine. It should be unnecessary for most of times. Default is false. ')
    parser.add_argument('-use_d_thd', dest='use_d_thd', action='store_false', default=True,
                        help='Use a distance threshold (default: 15mm) between counterrotating cores to terminate processes.')

    # Parameters about how to compute circulation
    parser.add_argument('-NP', dest='NP', type=int, default=800,
                        help='Number of points to sample along the circulation contour')
    parser.add_argument('-min_radius', dest='min_radius', type=float, default=10,
                        help='Smallest radius of circulation contour explored (pixels)')
    parser.add_argument('-max_radius', dest='max_radius', type=float, default=70,
                        help='Largest radius of circulation contour explored (pixels)')
    parser.add_argument('-sample_pts', dest='sample_pts', type=int, default=10,
                        help='number of points between min and max radius at which to sample the circulation')
    parser.add_argument('-cm_shift', dest='cm_shift', type=int, default=10,
                        help='Largest amount to shift the center of the circulation contour in px')


    # Parameters related to videos
    parser.add_argument('-scale', dest='scale', type=float, default=None, help='mm/px')
    parser.add_argument('-rate', dest='rate', type=float, default=None, help='fps')

    # Parameters related to PIV
    parser.add_argument('-image_spacing', dest='image_spacing', type=float, default=1,
                        help='number of frames between a image pair')
    parser.add_argument('-frame_spacing', dest='frame_spacing', type=float, default=10,
                        help='number of frames between successive image pairs')
    parser.add_argument('-box_size', dest='box_size', type=int, default=32,
                        help='width of the box used to compute correlation between frames in PIVLab')
    parser.add_argument('-omegabool', dest='omegabool', action='store_false', default=True,
                        help='If added, it does not read vorticity values computed by PIVLab')

    # Parameters related to outputs
    parser.add_argument('-plot_spacing', dest='plot_spacing', type=int, default=50,
                        help='spacing between circulation curves are plotted and saved')
    parser.add_argument('-save_circ', dest='save_circ', action='store_true', default=False,
                        help='If added, save the png of the circulation vs contour radius plot, JSON is saved regardless the value of -save_circ')



    # PARSE COMMAND LINE INPUTS
    args = parser.parse_args()

    cine_inputs = args.input
    NP = args.NP
    min_radius = args.min_radius
    max_radius = args.max_radius
    sample_pts = args.sample_pts
    cm_shift = args.cm_shift
    save_circ = args.save_circ
    scale = args.scale
    rate = args.rate
    image_spacing = args.image_spacing
    frame_spacing = args.frame_spacing
    plot_spacing = args.plot_spacing
    omegabool = args.omegabool
    process_all = args.process_all
    dt = frame_spacing/rate
    box_size = args.box_size
    fileskip = args.fileskip

    # SETUP SOME VARIABLES FOR PLOTTING TO BE USED THROUGHOUT SCRIPT
    radii = np.linspace(min_radius * scale, max_radius * scale, num=sample_pts, endpoint=True) # in mm
    radii_diff = (max_radius * scale - min_radius * scale) / float(sample_pts - 1)
    phi = np.arange(NP) * 2 * np.pi / float(NP)

    gammar_all, vr_all, dr_all = [], [], []
    span = []

    # for plots
    gammar_lim, vr_lim, dr_lim = 0, 0, 0
    colors = graph.get_first_n_colors_from_color_cycle(4)  # colors corresponding to domains
    # Bounds for color bars in the velocity / vorticity heat map
    ux_limit = cutoffu * scale * rate / 1.4
    uy_limit = cutoffu * scale * rate / 1.4
    w_limit = cutoffomega * rate / 1.4
    cine_inputs = cine_inputs[fileskip:]


    #figure settings
    graph.reset_figure_params()


    for cnum, cine_file in enumerate(cine_inputs):
        # Ring velocity, ring diameter, circulation, vortex rsssing core position(x, y)
        trForVr, vxr, vyr, vr =[], [], [], []
        trForDr, dr = [], []
        trForGammarPos, gammarPos, gammarPos_err, cxmaxlist, cymaxlist, cxminlist, cyminlist = [], [], [], [], [], [], []
        cxlist, cylist = [], []
        time = []
        d12_list, d13_list, d24_list, d34_list = [], [], [], []


        # LOAD CINE FILE AND GRUB IMAGE SIZE
        movie = cine.open(cine_file)
        imsize = np.shape(movie[0])



        # GENERATE FILE ARCHITECTURE
        date_dir, cine_name = os.path.split(cine_file)
        name, ext = os.path.splitext(cine_name)
        # cine_dir = os.path.join(date_dir, name)
        resultsdir = date_dir + '/PIV_AnalysisResults/' + name  #ABS PATH TO OUTPUT DIRECTORY

        # Get stroke length from name of cine file
        try:
            span = fs.get_float_from_str(name, 'piston', 'mm_freq')
            vp_c = fs.get_float_from_str(name, 'Hz_v', 'mms')
        except ValueError:
            span = float(browse.replace_letter_in_string(span, 'p', '.'))
            vp_c = fs.get_float_from_str(name, 'Hz_v', 'mms')


        print '-----------------------------------------------------------'
        print 'Working on Cine file: ', name

        # # CREATE A DIRECTORY TO STORE RESULTS
        # if not os.path.exists(resultsdir):
        #     os.makedirs(resultsdir)

        # CREATE A DIRECTORY TO STORE RESULTS OF CIRCULATION COMPUTATION
        circulation_dir = resultsdir + '/circulation/'
        if not os.path.exists(circulation_dir):
            os.makedirs(circulation_dir)

        # GRAB A DIRECTORY NAME WHERE PIVLAB-GENERATED txt FILES ARE STORED
        data_dir = date_dir + '/PIV_W%s_step%s_data' % (box_size, int(image_spacing)) + \
                   '/PIVlab_ratio2_W%spix_Dt_%s_' % (box_size, int(image_spacing)) + name



        # CHECK IF DATA FILES(txt FILES GENERATED BY PIVLAB) EXIST
        if not os.path.exists(data_dir):
            print 'NO DATA DIRECTORY FOUND! EXITING'
            print 'data_dir is supposed to be ... ' + data_dir
            sys.exit()

        # INITIALIZE EMTPY LISTS FOR ROBUST GAMMA COMPUTATIONS
        robust_gammas = []
        robust_radii = []
        robust_frames = []
        robust_wav_gammas = []
        robust_wav_stds = []

        # ITERATE THROUGH FRAMES IN CINE FILE
        if args.stop == 0:
            frames = range(args.start, movie.__len__(), args.skip)
        else:
            frames = range(args.start, args.stop, args.skip)
        print 'Working on frame range: (%d:%d)' % (frames[0], frames[-1])

        # Read PIVLab data of the corresponding cine, and compute circulation, ring vel, and diameter
        for i, f in enumerate(frames):
            # Convert frame to sec
            time.append(f / float(rate))

            if f % plot_spacing == 0:
                print '-----------------------------------------------------------'
                print 'Processing frame %d' % f
                print 'image size in px (y,x): ', imsize
                try:
                    i += frames[0] / frame_spacing
                except TypeError:
                    print 'NO FRAME SPACING SPECIFIED! EXITING'
                # Read data from txt files generated by PIVLab
                print 'Attempting to read the txt data from...:'
                print os.path.join(data_dir, 'D%04d.txt' % f)

                if os.path.exists(os.path.join(data_dir, 'D%06d.txt' % f)):
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, 'D%06d.txt' % f))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, 'D%06d.txt' % f))
                    print 'Loaded D%06d.txt' % f
                elif os.path.exists(os.path.join(data_dir, 'D%05d.txt' % f)):
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, 'D%05d.txt' % f))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, 'D%05d.txt' % f))
                    print 'Loaded D%05d.txt' % f
                elif os.path.exists(os.path.join(data_dir, 'D%04d.txt' % f)):
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, 'D%04d.txt' % f))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, 'D%04d.txt' % f))
                    print '...Loaded D%04d.txt' % f
                elif os.path.exists(os.path.join(data_dir, 'D%03d.txt' % f)):
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, 'D%03d.txt' % f))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, 'D%03d.txt' % f))
                    print '...Loaded D%03d.txt' % f
                elif os.path.exists(os.path.join(data_dir, 'D%02d.txt' % f)):
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, 'D%02d.txt' % f))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, 'D%02d.txt' % f))
                    print '...Loaded D%02d.txt' % f
                elif os.path.exists(os.path.join(data_dir, 'D%01d.txt' % f)):
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, 'D%01d.txt' % f))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, 'D%01d.txt' % f))
                    print '...Loaded D%01d.txt' % f
                else:
                    print 'NO DATA EXISTS FOR FRAME: %d; SKIPPING!' % f


                #Clean data by excluding unreasonable values and linearly interpolating excluded data points
                print '---------------'
                print 'Cleaning ux... cutoff is ' + str(cutoffu * scale * rate) + 'mm/s'
                ux = process.clean_multi_dim_array(ux, cutoff=cutoffu, verbose=False)
                print 'Cleaning uy... cutoff is ' + str(cutoffu * scale * rate) + 'mm/s'
                uy = process.clean_multi_dim_array(uy, cutoff=cutoffu, verbose=False)
                print 'Cleaning omega... cutoff is ' + str(cutoffomega * rate) + '1/s'
                omega = process.clean_multi_dim_array(omega, cutoff=cutoffomega, verbose=False)
                print '---------------'

                # Figure out the dimension of 2D data (nx, ny)
                nx, ny = (x[-1] - x[0]) * 2 / box_size + 1, (y[-1] - y[0]) * 2 / box_size + 1

                # Reshape data into 2d array(ny, nx)
                xgrid = np.array(x).reshape((ny, nx))
                ygrid = np.array(y).reshape((ny, nx))
                omegagrid = np.array(omega).reshape((ny, nx))
                uxgrid = np.array(ux).reshape((ny, nx))
                uygrid = np.array(uy).reshape((ny, nx))

                # COMPUTE INTERPOLATED VELOCITY AND VORTICITY
                # CONVERT PX -> MM AND FRAME -> SEC
                Xgrid, Ygrid, iuxgrid = interp_flow_component(x * scale, y * scale, ux * scale * rate)
                Xgrid, Ygrid, iuygrid = interp_flow_component(x * scale, y * scale, uy * scale * rate)
                Xgrid, Ygrid, iomegagrid = interp_flow_component(x * scale, y * scale, omega * rate)
                nrows, ncolumns = Xgrid.shape
                xmin, xmax, ymin, ymax = min(Xgrid.flatten()), max(Xgrid.flatten()),\
                                         min(Ygrid.flatten()), max(Ygrid.flatten())
                width, height = xmax - xmin, ymax - ymin

                print 'Window dimension in mm: (xmin, xmax, ymin, ymax)=(%.2f, %.2f, %.2f, %.2f)'\
                      % (xmin, xmax, ymin, ymax)

                # iOmega Plot
                fig = plt.figure(figsize=(10, 5))
                img3 = fig.add_subplot(111)
                ax3 = img3.imshow(iomegagrid, cmap=cmap2, vmin=-w_limit, vmax=w_limit, interpolation='gaussian', \
                                  extent=(0, 150, 90, 1))
                plt.title('$t=%.3f $sec.' % time[-1])
                img3.set_xlabel('X $[mm]$')
                img3.set_ylabel('Y $[mm]$')
                cb = colorbar(ax3)
                cb.set_label('$\omega_z [1/s]$')
                savedir = resultsdir + '/movie_omega/'
                filename = 'omega_D%05d' % f
                graph.save(savedir + filename, ext='png', close=True)
    print 'Done'