"""
Make a velocity field generated by a pair of two Lamb-Oseen vortices

"""
import os
import numpy as np
import argparse
import matplotlib.pyplot as plt

import library.basics.formatstring as fs
import library.display.graph as graph
import library.tools.vectools as vec
import library.tools.rw_data as rw

parser = argparse.ArgumentParser(description='Generate a velocity field by a pair of Lamb-Oseen vorticies')
parser.add_argument('-mode', '--mode', help='Choose from constant and gradient', type=str, default='constant')
parser.add_argument('-width', '--width', help='width of generated velocity field ', type=int, default=1280)
parser.add_argument('-height', '--height', help='height of generated velocity field ', type=int, default=800)

# Velocity field
# Direction
parser.add_argument('-theta', '--theta', help='Angle to specify a direction in degrees', type=float, default=0)
# Specific to mode == 'constant'
parser.add_argument('-mag', '--mag', help='Magnitude of velocity', type=float, default=1.)
# Specific to mode == 'gradient'
parser.add_argument('-max', '--max', help='Max. magnitude of velocity', type=float, default=1.)
parser.add_argument('-min', '--min', help='Min. magnitude of velocity', type=float, default=0)

# output location
parser.add_argument('-resultdir', '--resultdir', help='Path where outputs will be stored', type=str,
                    default='/Volumes/labshared3-1/takumi/JHTD-sample/JHT_Database/Data/synthetic_data_unidirectional/org_vel_field/')

# Convert results into mm, s from px, frame?
parser.add_argument('--convert', dest='convert', action='store_true', default=False,
                    help='If true, convert values into mm, s from px, frame')
parser.add_argument('-fps', '--fps', help='frame rate... will be used to convert from px, frame to mm, s', type=float, default=500)
parser.add_argument('-scale', '--scale', help='px-to-mm conversion factor (mm/px).', type=float, default=0.2)

args = parser.parse_args()

# name string
filename = 'unidirectional_%s' % args.mode
filename += '_theta{0:0.1f}'.format(args.theta).replace('.', 'p') + '_mag{0:0.2f}'.format(args.mag).replace('.', 'p')
filename += '_min{0:0.2f}'.format(args.min).replace('.', 'p') + '_max{0:0.2f}'.format(args.max).replace('.', 'p')
filename += '_width{0}_height{1}'.format(args.width, args.height)
if args.convert:
    filename += 'fps{0}_scale{1:0.2f}'.format(args.fps, args.scale)
print filename

# X, Y grids
xx, yy = np.arange(args.width).astype(float), np.arange(args.height).astype(float)
xgrid, ygrid = np.meshgrid(xx, yy)

# Generate a velocity field
if args.mode == 'constant':
    ugrid = np.ones((args.height, args.width)) * args.mag * np.cos(args.theta * np.pi / 180.)
    vgrid = np.ones((args.height, args.width)) * args.mag * np.sin(args.theta * np.pi / 180.)

    vel = np.stack((ugrid, vgrid))
    omega = vec.curl(vel)

if args.mode == 'gradient':
    # def rotate(u, x, y, theta):
    #     uu, vv = np.cos(theta * np.pi / 180.), np.sin(theta * np.pi / 180.)
    #
    #     slope = - (args.max - args.min) / float(args.width)
    #     r = x * np.cos(theta * np.pi / 180.) + y * np.sin(theta * np.pi / 180.)
    #     u_new = u + slope * r
    #     return u_new

    uu, vv = np.cos(args.theta * np.pi / 180.), np.sin(args.theta * np.pi / 180.)
    slope = - (args.max - args.min) / np.sqrt((args.width * np.cos(args.theta * np.pi / 180.))**2 + (args.height * np.sin(args.theta * np.pi / 180.))**2)
    rgrid = xgrid * np.cos(args.theta * np.pi / 180.) + ygrid * np.sin(args.theta * np.pi / 180.)
    vel_mag = np.ones((args.height, args.width)) * args.max + slope * rgrid
    ugrid, vgrid = vel_mag * np.cos(args.theta * np.pi / 180.), vel_mag * np.sin(args.theta * np.pi / 180.)
    # ugrid = np.ones((args.height, args.width)) * args.mag * np.cos(args.theta * np.pi / 180.)
    # vgrid = np.ones((args.height, args.width)) * args.mag * np.sin(args.theta * np.pi / 180.)
    # print ugrid.shape, xgrid.shape

    vel = np.stack((ugrid, vgrid))
    omega = vec.curl(vel)

# # Debugging purpose
# fig1 = plt.figure(1)
# ax1 = fig1.add_subplot(111)
# ax1.quiver(xgrid, ygrid, ugrid, vgrid)
# plt.show()

data = {}
data['x'] = xgrid
data['y'] = ygrid
data['ux'] = ugrid
data['uy'] = vgrid
data['omega'] = omega #for unidirectional flow, vorticity is zero
datapath = args.resultdir + filename
rw.write_hdf5_dict(datapath, data)