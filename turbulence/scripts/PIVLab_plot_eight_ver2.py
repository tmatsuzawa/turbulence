#!/usr/bin/env python
"""
Finds up to four vortex rings and compute circulation, vring, and diameter of each ring
- Computes and plots circulation at every args.plot_spacing frames
- Computes and plots circulation velocity and radius of vortex rings over time

... Note that PIVLab outputs x,y in pixels!
"""
import argparse
import os
import sys
import cine
import json
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import matplotlib.path as path
import pickle
from matplotlib import cm
from matplotlib.widgets import RectangleSelector
from scipy import ndimage, interpolate
from mpl_toolkits.axes_grid1 import make_axes_locatable
from scipy import ndimage
# import ilpm.cine as cine
import numpy as np
import math

from scipy.interpolate import interp1d
from scipy.ndimage import map_coordinates

import library.tools.browse as browse
import library.tools.process_data as process
import library.display.graph as graph
import library.basics.formatstring as fs
import library.basics.formatarray as fa
import library.basics.roipoly as roipoly


cmap = cm.spectral
cmap2 = cm.bwr
colorcycle = graph.get_default_color_cycle()

cx_lim = 100
cy_lim = 100

# Extract a fraction of vorticity data around a position of maximum/minimum vorticity
# Unless the cores are near the edge, it gets grids with dimension (nx_frac * 2 + 1, ny_frac * 2 + 1)
nx_frac, ny_frac = 7, 7

# thresholds
gamma_thd = 1000.0 # in mm^2/s
d_thd = 10 # in mm;  threshold to stop the circulation computation
d_thd_opp_core = 5 # in mm; threshold to alert if the detected cores are too close to each other

# cutoff values for cleaning raw data
cutoffu = 5.  #px/frame
cutoffomega = 0.2 #/frame

# new grid spacing in mm
__xint__, __yint__ = 1., 1.

# ratios used to divide a window into quadrants (See a figure below)
rx, ry = 0.5, 0.5

# Frequencey of computing ring velocity
vrtimestep = 1  # compute vr every n steps

#
global proceed, use_roi, redo, rec_x_ini, rec_y_ini, rec_x_fin, rec_y_fin, is_core_in_window, terminate
core_check_thd = 0.1
proceed = True
use_roi = False
redo = True
is_core_in_window = True
terminate = False


def load_matlab_data(datapath):
    """Reads data from .txt files generated by PIVlab and places them into numpy arrays

    Parameters
    ----------
    data_loc : str
        The directory containing .txt files generated from PIVlab

    Returns
    -------
    x, y, ux, uy, omega array (floats)
        coordinates, velocity components, and vorticity calculated by PIVlab
    """
    file = open(datapath)
    x, y, ux, uy, omega = [], [], [], [], []
    for i, line in enumerate(file):
        if i < 3:
            continue
        for j, val in enumerate(line.split(',')):
            if j == 0:
                x.append(int(val))
            elif j == 1:
                y.append(int(val))
            elif j == 2:
                ux.append(float(val))
            elif j == 3:
                uy.append(float(val))  # Note that there is a minus sign due to the default coordinate system in PIVLab.
            elif j == 4:
                omega.append(float(val))

    if j == 4:
        x, y, ux, uy, omega = map(lambda z: np.asarray(z), [x, y, ux, uy, omega])
        return x, y, ux, uy, omega
    elif j == 3:
        x, y, ux, uy = map(lambda z: np.asarray(z), [x, y, ux, uy])
        return x, y, ux, uy

def interp_flow_component(x, y, ux, xint=__xint__, yint=__yint__, method='linear'):
    """
    Interpolate x,y, and data (ux) into x_new which has interval of __xint__
    Parameters
    ----------
    x
    y
    ux
    xint
    yint
    method

    Returns
    -------
    Xnew, Ynew: x and y coordinates of a grid
    datanew : 2d numpy array

    """
    uxindicies = [(xx, yy) for xx, yy in zip(x, y)]
    # grid_ind0, grid_ind1 = mgrid[0:imsize[0], 0:imsize[1]]
    # griddata = interpolate.griddata(uxindicies, ux, (grid_ind0, grid_ind1), method=method, fill_value=0.)
    xmin, xmax, ymin, ymax = np.min(x), np.max(x), np.min(y), np.max(y)

    xnew, ynew = np.arange(xmin, xmax + xint, xint), np.arange(ymin, ymax + yint, yint)
    Xnew, Ynew = np.meshgrid(xnew, ynew)
    griddata = interpolate.griddata(uxindicies, ux, (Xnew, Ynew), method=method, fill_value=0.)

    return Xnew, Ynew, griddata

def interp_for_pcolormesh(x, y, data, xint=__xint__, yint=__yint__, method='cubic'):
    """
    (PIVLab only)
    Takes 1d arrays for x, y, data, and generate a grid, interpolate data,
    and give back grids (2d arrays generated by np.meshgrid) and interpolated data
    One can immediately generate a heatmap by using pcolormesh(Xnew, Ynew, datanew)

    Parameters
    ----------
    x 1d array
    y 1d array
    data 1d array
    xint interval of new x, float
    yint interval of new x, float
    method method of interpolation, str
           Refer to interpolate.interp2d for available options

    Returns
    -------
    Xnew 2d array generated by np.meshgrid
    Ynew 2d array generated by np.meshgrid
    datanew 2d array

    """
    f = interpolate.interp2d(x, y, data, kind=method)

    # make a meshgrid
    xnew, ynew = np.arange(x[0], x[-1] + xint, xint), np.arange(y[0], y[-1] + yint, yint)
    Xnew, Ynew = np.meshgrid(xnew, ynew)
    # interpolate using scipy.interpolate.inter2d
    datanew = f(xnew, ynew)

    return Xnew, Ynew, datanew

def colorbar(mappable, location='right'):
    ax = mappable.axes
    fig = ax.figure
    divider = make_axes_locatable(ax)
    cax = divider.append_axes(location, size='5%', pad=0.05)
    return fig.colorbar(mappable, cax=cax)

def weighted_mean(means, stds):
    """
    Compute weighted arithmetic mean
    Parameters
    ----------
    means : list (floats)
        list of mean values
    stds : list (floats)
        list of standard deviations associated to means

    Returns
    -------
    weighted_mean : float
    """
    return sum(np.asarray(means * (1. / np.asarray(stds)))) / sum(1. / np.asarray(stds))

def weighted_mean_std(stds):
    """
    Compute the uncertainty for a weighted mean
    Parameters
    ----------
    stds : list (floats)
        list of standard deviations associated to means

    Returns
    -------
    weighted_mean_std : float
    """
    return np.sqrt(1. / sum(1. / np.asarray(stds)))

def find_center_of_arr2d(arr):
    """
    Returns a center of 2d array
    For example, if the array contains mass distribution, then this returns the center of mass.
    Parameters
    ----------
    arr

    Returns
    -------

    """
    arr = np.array(arr)
    cx, cy = 0, 0
    for i in range(arr.shape[0]):
        for j in range(arr.shape[1]):
            cx = i * arr[i][j]
            cy = j * arr[i][j]
    cx, cy = cx / arr.sum(), cy / arr.sum()
    return cx, cy

def compute_dist(x1, y1, x2, y2):
    """Compute distance between two points (x1,y1) and (x2,y2)"""
    return float(np.sqrt((x1-x2)**2. + (y1-y2)**2.))

def compute_circulation(iuxgrid, iuygrid, cx, cy, radii, phi, cm_shift, scale):
    for r in radii:
        path_x, path_y = r * np.cos(phi) + cx, r * np.sin(phi) + cy
        iux_p = ndimage.map_coordinates(iuxgrid, (path_y / __yint__, path_x / __xint__), order=1)
        iuy_p = ndimage.map_coordinates(iuygrid, (path_y / __yint__, path_x / __xint__), order=1)

        # CALCULATE AND PLOT CIRCULATIONS AND STATISTICS
        gammas = []
        cm_shift_list = np.linspace(-cm_shift * scale, cm_shift * scale, num=10)
        for off_i in cm_shift_list:
            for off_j in cm_shift_list:
                ds = 2 * np.pi * r / float(NP)
                path_x, path_y = r * np.cos(phi) + cx + off_i, r * np.sin(phi) + cy + off_j
                iux_p = ndimage.map_coordinates(iuxgrid, (path_y / __yint__, path_x / __xint__), order=1)
                iuy_p = ndimage.map_coordinates(iuygrid, (path_y / __yint__, path_x / __xint__), order=1)
                gammas.append(sum((-iux_p * np.sin(phi) + iuy_p * np.cos(phi)) * ds))

        mean_g = np.mean(np.asarray(gammas))
        mean_gs.append(mean_g)
        std_g = np.std(np.asarray(gammas))
        std_gs.append(std_g)
    return radii, mean_gs, std_gs

def update_data_dict(dict, key, subkey, data=[]):
    """
    Generate a dictionary that stores effective velocity
    Parameters
    ----------
    dict
    key: span like span5.4
    subkey: commanded velocity, str
    data: effective velocity, float

    Returns
    -------

    """
    if not key in dict:
        dict[key] = {}  # Generate a sub-dictionary
    dict[key][subkey] = data
    return dict

def draw_quadrants(ax, rx, ry):
    """
    Draw two lines to show quadrants
    Parameters
    ----------
    ax
    rx
    ry

    Returns
    -------

    """
    xmin, xmax = ax.get_xlim()
    ymax, ymin = ax.get_ylim()
    width, height = xmax - xmin, ymax - ymin
    ax.axhline(ymin + height * ry)
    ax.axvline(xmin + width * rx)

def make_quadrants(xmin, xmax, ymin, ymax, rx, ry):
    """
    Make quadrants as matplotlib.path objects
    Return a list of quadrants as path objects

    Parameters
    ----------
    ax
    rx
    ry

    Returns
    -------

    """
    width, height = xmax - xmin, ymax - ymin
    # Quadrant 1
    verts1 = [
        (xmin, ymin),
        (xmin + width * rx, ymin),
        (xmin + width * rx, ymin + height * ry),
        (xmin, ymin + height * ry),
        (xmin, ymin)
    ]
    # Quadrant 2
    verts2 = [
        (xmin, ymin + height * ry),
        (xmin + width * rx, ymin + height * ry),
        (xmin + width * rx, ymax),
        (xmin, ymax),
        (xmin, ymin + height * ry)
    ]
    # Quadrant 3
    verts3 = [
        (xmin + width * rx, ymin),
        (xmax, ymin),
        (xmax, ymin + height * ry),
        (xmin + width * rx, ymin + height * ry),
        (xmin + width * rx, ymin)
    ]
    # Quadrant 4
    verts4 = [
        (xmin + width * rx, ymin + height * ry),
        (xmax, ymin + height * ry),
        (xmax, ymax),
        (xmin + width * rx, ymax),
        (xmin + width * rx, ymin + height * ry),
    ]
    codes = [path.Path.MOVETO,
             path.Path.LINETO,
             path.Path.LINETO,
             path.Path.LINETO,
             path.Path.CLOSEPOLY,
             ]
    quad1, quad2, quad3, quad4 = path.Path(verts1, codes), path.Path(verts2, codes), path.Path(verts3, codes), path.Path(verts4, codes)
    quads = [quad1, quad2, quad3, quad4]
    return quads

def get_proper_indices_for_x(a, ncolumns):
    if a < 0:
        return 0
    elif a >= ncolumns:
        return int(ncolumns - 1)
    else:
        return int(a)

def get_proper_indices_for_y(a, nrows):
    if a < 0:
        return 0
    elif a >= nrows:
        return int(nrows - 1)
    else:
        return int(a)

def get_small_grids_around_coord(griddata, xgrid, ygrid, x, y, nx, ny):
    nrows, ncolumns = griddata.shape
    griddata_around_coord = griddata[get_proper_indices_for_y(y - ny, nrows): get_proper_indices_for_y(y + ny, nrows),
                            get_proper_indices_for_x(x - nx, ncolumns): get_proper_indices_for_x(x + nx, ncolumns)]
    xgrid_around_coord = xgrid[get_proper_indices_for_y(y - ny, nrows): get_proper_indices_for_y(y + ny, nrows),
                         get_proper_indices_for_x(x - nx, ncolumns): get_proper_indices_for_x(x + nx, ncolumns)]
    ygrid_around_coord = ygrid[get_proper_indices_for_y(y - ny, nrows): get_proper_indices_for_y(y + ny, nrows),
                         get_proper_indices_for_x(x - nx, ncolumns): get_proper_indices_for_x(x + nx, ncolumns)]
    return xgrid_around_coord, ygrid_around_coord, griddata_around_coord

####
def redefine_rx(event):
    """
    Click a point to redefine rx
    Click outside the image to apply the change
    Parameters
    ----------
    event

    Returns
    -------

    """
    global rx, terminate, roi_bool, polylines, reject, use_roi, redo
    print 'CLICK A POINT TO REDEFINE rx. CLICK OUTSIDE THE PLOT TO CLOSE THE PLOT.'
    xmin, xmax = ax.get_xlim()
    ymax, ymin = ax.get_ylim()
    if event.key == 'd':
        global redo
        print 'Redo core detection!'
        redo = True
        print 'REDO redefine rx: %r' %redo
    elif event.key == 't':
        print 'You pressed %s. Terminating computations after this step...' % event.key
        terminate = True
        fig.canvas.mpl_disconnect(cid)
        plt.close()
    elif event.key == 'r':
        print 'You pressed %s. Draw ROI' % event.key
        use_roi = True
        redo = True
        plt.close()
    elif event.key == 'p':
        print 'You pressed %s. Pass' % event.key
        redo = False
        plt.close()


    if event.xdata is not None and event.ydata is not None:
        print 'redefine_rx: %.2f. %.2f' % (event.xdata, event.ydata)
        plt.axvline(x=event.xdata)
        #fig.canvas.flush_events()
        plt.show()
        rx = (event.xdata - xmin) / xmax
        print 'rx: %.2f' % rx
    else:
        print 'Exitting... rx = %.2f' % rx
        fig.canvas.mpl_disconnect(cid)
        plt.close()

def redefine_ry(event):
    """
    Click a point to redefine ry
    Click outside the image to apply the change
    Parameters
    ----------
    event

    Returns
    -------

    """
    global ry, terminate, roi_bool, polylines, reject, use_roi, redo
    print 'CLICK A POINT TO REDEFINE ry. CLICK OUTSIDE THE PLOT TO CLOSE THE PLOT.'
    xmin, xmax = ax.get_xlim()
    ymax, ymin = ax.get_ylim()
    if event.key == 'd':
        global redo
        print 'Redo core detection!'
        redo = True
        print 'REDO redefine ry: %r' %redo
    elif event.key == 't':
        print 'You pressed %s. Terminating computations after this step...' % event.key
        terminate = True
        fig.canvas.mpl_disconnect(cid)
        plt.close()
    elif event.key == 'r':
        print 'You pressed %s. Draw ROI' % event.key
        use_roi = True
        redo = True
        plt.close()
    elif event.key == 'p':
        print 'You pressed %s. Pass' % event.key
        redo = False
        plt.close()


    if event.xdata is not None and event.ydata is not None:
        print 'redefine_ry: %.2f. %.2f' % (event.xdata, event.ydata)
        plt.axhline(y=event.ydata)
        #fig.canvas.flush_events()
        plt.show()
        ry = (event.ydata - ymin) / ymax
        print 'ry: %.2f' % ry
    else:
        print 'Exitting... ry = %.2f' % ry
        fig.canvas.mpl_disconnect(cid)
        plt.close()

def draw_trajectory(data_dict, show=True):
    fig3, ax31 = graph.set_fig(fignum=3, subplot=111, figsize=(16, 10))
    for domain_num in range(1, 5):
        # these are lists of core positions
        cxmax = data_dict["domain{0}".format(domain_num)]["cxmaxlist"]
        cymax = data_dict["domain{0}".format(domain_num)]["cymaxlist"]
        cxmin = data_dict["domain{0}".format(domain_num)]["cxminlist"]
        cymin = data_dict["domain{0}".format(domain_num)]["cyminlist"]

        core_positions = [[cxmax, cymax], [cxmin, cymin]]

        # For plot
        marker = ['v', '^', 's', 'o']  # makers corresponding to domains
        fillstyle = ['full', 'none']  # Positive core: fill, Negative core: no fill
        colors = graph.get_first_n_colors_from_color_cycle(4)

        for j, core_position in enumerate(core_positions):
            print core_position
            cx, cy = core_position[0], core_position[1]
            ax31.plot(cx, cy, color=colors[domain_num - 1], marker=marker[domain_num - 1],
                      alpha=0.7, fillstyle=fillstyle[j])
            graph.setaxes(ax31, 0, imsize[1] * scale, 0, imsize[0] * scale)
            graph.labelaxes(ax31, 'x [mm]', 'y [mm]')
            ax31.invert_yaxis()
        if show:
            graph.show()

def initialize_good_core_bools(data_dict):
    for domain_num in range(1,5):
        data_dict["domain{0}".format(domain_num)]['good_corePos'] = False
        data_dict["domain{0}".format(domain_num)]['good_coreNeg'] = False
    return data_dict


def line_select_callback(eclick, erelease):
    'eclick and erelease are the press and release events'
    global rec_x_ini, rec_y_ini, rec_x_fin, rec_y_fin
    rec_x_ini, rec_y_ini = eclick.xdata, eclick.ydata
    rec_x_fin, rec_y_fin = erelease.xdata, erelease.ydata
    print("(%3.2f, %3.2f) --> (%3.2f, %3.2f)" % (rec_x_ini, rec_y_ini, rec_x_fin, rec_y_fin))
    print(" The button you used were: %s %s" % (eclick.button, erelease.button))

def toggle_selector(event):
    global rec_x_ini, rec_y_ini, rec_x_fin, rec_y_fin, is_core_in_window, use_roi
    print('Key %s pressed.' % event.key)
    if event.key in ['Q', 'q'] and toggle_selector.RS.active:
        print(' RectangleSelector deactivated.')
        toggle_selector.RS.set_active(False)
    if event.key in ['A', 'a'] and not toggle_selector.RS.active:
        print(' RectangleSelector activated.')
        toggle_selector.RS.set_active(True)
    if event.key == 'c':
        plt.close()
    if event.key == 'u':
        print 'Escape from the ROI mode'
        use_roi = False

    if event.key == 'n':
        rec_x_ini, rec_y_ini, rec_x_fin, rec_y_fin = np.nan, np.nan, np.nan, np.nan
        is_core_in_window = False
        print('The core is not in the window!')
        plt.close()
    # In case n was pressed by mistake, the following line reverses the effect
    if event.key == 'm':
        is_core_in_window = True
        print('The core is in the window!')


def check_cores(event):
    """
    Decide whether you would like to accept the detected cores (press p for pass)
    or redo the core detection in the ROI mode (press n for not good)
    Parameters
    ----------
    event

    Returns
    -------

    """
    global use_roi, redo, terminate
    print 'Press p if all cores are good, and press r to redo core detection using ROI'
    print 'You pressed %s. ' % event.key
    if event.key == 'p':
        print 'All cores look good. Keep processing'
        redo = False
        fig.canvas.mpl_disconnect(cid)
        plt.close()
    if event.key == 'r':
        print 'Redo core detection using ROI'
        use_roi = True
        redo = True
        fig.canvas.mpl_disconnect(cid)
        plt.close()
    if event.key == 't':
        print 'Terminate.'
        terminate = True
        redo = False
        fig.canvas.mpl_disconnect(cid)
        plt.close()


if __name__ == '__main__':
    """
    Pass a absolute path of the cine files through '-input' e.g. -input '/absolute/path/to/cineDir/*.cine'
    """
    parser = argparse.ArgumentParser(description='')
    # Parameter to specify a data location
    parser.add_argument('-input', metavar='input', type=str, nargs='*', default=None, help='e.g. -input /absolute/path/to/cineDir/*.cine')
    # Parameters to specify the region in which the analysis is conducted
    parser.add_argument('-start', dest='start', type=int, default=0, help='Frame number to start the analysis')
    parser.add_argument('-stop', dest='stop', type=int, default=0, help='Frame number to end the analysis')
    parser.add_argument('-skip', dest='skip', type=int, default=10, help='Use every "skip" frames for analysis. default=10')
    parser.add_argument('-fileskip', dest='fileskip', type=int, default=0,
                        help='number of cines to skip in the cine list')
    parser.add_argument('-process_all', dest='process_all', action='store_true', default=False,
                        help='If added, compute circulation for ALL frames in cine. It should be unnecessary for most of times. Default is false. ')
    parser.add_argument('-use_d_thd', dest='use_d_thd', action='store_false', default=True,
                        help='Use a distance threshold (default: 15mm) between counterrotating cores to terminate processes.')

    # Parameters about how to compute circulation
    parser.add_argument('-NP', dest='NP', type=int, default=800,
                        help='Number of points to sample along the circulation contour')
    parser.add_argument('-min_radius', dest='min_radius', type=float, default=10,
                        help='Smallest radius of circulation contour explored (pixels)')
    parser.add_argument('-max_radius', dest='max_radius', type=float, default=70,
                        help='Largest radius of circulation contour explored (pixels)')
    parser.add_argument('-sample_pts', dest='sample_pts', type=int, default=10,
                        help='number of points between min and max radius at which to sample the circulation')
    parser.add_argument('-cm_shift', dest='cm_shift', type=int, default=10,
                        help='Largest amount to shift the center of the circulation contour in px')


    # Parameters related to videos
    parser.add_argument('-scale', dest='scale', type=float, default=None, help='mm/px')
    parser.add_argument('-rate', dest='rate', type=float, default=None, help='fps')

    # Parameters related to PIV
    parser.add_argument('-image_spacing', dest='image_spacing', type=float, default=1,
                        help='number of frames between a image pair')
    parser.add_argument('-frame_spacing', dest='frame_spacing', type=float, default=10,
                        help='number of frames between successive image pairs')
    parser.add_argument('-box_size', dest='box_size', type=int, default=32,
                        help='width of the box used to compute correlation between frames in PIVLab')
    parser.add_argument('-omegabool', dest='omegabool', action='store_false', default=True,
                        help='If added, it does not read vorticity values computed by PIVLab')

    # Parameters related to outputs
    parser.add_argument('-plot_spacing', dest='plot_spacing', type=int, default=50,
                        help='spacing between circulation curves are plotted and saved')
    parser.add_argument('-save_circ', dest='save_circ', action='store_true', default=False,
                        help='If added, save the png of the circulation vs contour radius plot, JSON is saved regardless the value of -save_circ')



    # PARSE COMMAND LINE INPUTS
    args = parser.parse_args()

    cine_inputs = args.input
    NP = args.NP
    min_radius = args.min_radius
    max_radius = args.max_radius
    sample_pts = args.sample_pts
    cm_shift = args.cm_shift
    save_circ = args.save_circ
    scale = args.scale
    rate = args.rate
    image_spacing = args.image_spacing
    frame_spacing = args.frame_spacing
    plot_spacing = args.plot_spacing
    omegabool = args.omegabool
    process_all = args.process_all
    dt = frame_spacing/rate
    box_size = args.box_size
    fileskip = args.fileskip

    # SETUP SOME VARIABLES FOR PLOTTING TO BE USED THROUGHOUT SCRIPT
    radii = np.linspace(min_radius * scale, max_radius * scale, num=sample_pts, endpoint=True) # in mm
    radii_diff = (max_radius * scale - min_radius * scale) / float(sample_pts - 1)
    phi = np.arange(NP) * 2 * np.pi / float(NP)

    gammar_all, vr_all, dr_all = [], [], []
    span = []

    # for plots
    gammar_lim, vr_lim, dr_lim = 0, 0, 0
    colors = graph.get_first_n_colors_from_color_cycle(4)  # colors corresponding to domains
    # Bounds for color bars in the velocity / vorticity heat map
    ux_limit = cutoffu * scale * rate / 1.4
    uy_limit = cutoffu * scale * rate / 1.4
    w_limit = cutoffomega * rate / 1.4
    cine_inputs = cine_inputs[fileskip:]
    for cnum, cine_file in enumerate(cine_inputs):
        # Ring velocity, ring diameter, circulation, vortex rsssing core position(x, y)
        trForVr, vxr, vyr, vr =[], [], [], []
        trForDr, dr = [], []
        trForGammarPos, gammarPos, gammarPos_err, cxmaxlist, cymaxlist, cxminlist, cyminlist = [], [], [], [], [], [], []
        cxlist, cylist = [], []
        time = []
        d12_list, d13_list, d24_list, d34_list = [], [], [], []


        # LOAD CINE FILE AND GRUB IMAGE SIZE
        movie = cine.open(cine_file)
        imsize = np.shape(movie[0])



        # GENERATE FILE ARCHITECTURE
        date_dir, cine_name = os.path.split(cine_file)
        name, ext = os.path.splitext(cine_name)
        # cine_dir = os.path.join(date_dir, name)
        resultsdir = date_dir + '/PIV_AnalysisResults/' + name  #ABS PATH TO OUTPUT DIRECTORY

        # Get stroke length from name of cine file
        try:
            span = fs.get_float_from_str(name, 'piston', 'mm_freq')
            vp_c = fs.get_float_from_str(name, 'Hz_v', 'mms')
        except ValueError:
            span = float(browse.replace_letter_in_string(span, 'p', '.'))
            vp_c = fs.get_float_from_str(name, 'Hz_v', 'mms')


        print '-----------------------------------------------------------'
        print 'Working on Cine file: ', name

        # # CREATE A DIRECTORY TO STORE RESULTS
        # if not os.path.exists(resultsdir):
        #     os.makedirs(resultsdir)

        # CREATE A DIRECTORY TO STORE RESULTS OF CIRCULATION COMPUTATION
        circulation_dir = resultsdir + '/circulation/'
        if not os.path.exists(circulation_dir):
            os.makedirs(circulation_dir)

        # GRAB A DIRECTORY NAME WHERE PIVLAB-GENERATED txt FILES ARE STORED
        data_dir = date_dir + '/PIV_W%s_step%s_data' % (box_size, int(image_spacing)) + \
                   '/PIVlab_ratio2_W%spix_Dt_%s_' % (box_size, int(image_spacing)) + name



        # CHECK IF DATA FILES(txt FILES GENERATED BY PIVLAB) EXIST
        if not os.path.exists(data_dir):
            print 'NO DATA DIRECTORY FOUND! EXITING'
            print 'data_dir is supposed to be ... ' + data_dir
            sys.exit()

        # INITIALIZE EMTPY LISTS FOR ROBUST GAMMA COMPUTATIONS
        robust_gammas = []
        robust_radii = []
        robust_frames = []
        robust_wav_gammas = []
        robust_wav_stds = []

        # ITERATE THROUGH FRAMES IN CINE FILE
        if args.stop == 0:
            frames = range(args.start, movie.__len__(), args.skip)
        else:
            frames = range(args.start, args.stop, args.skip)
        print 'Working on frame range: (%d:%d)' % (frames[0], frames[-1])

        # Initialize counters for velocity computation
        counter_dict = {'domain1Pos': 0, 'domain2Pos': 0, 'domain3Pos': 0, 'domain4Pos': 0,
                        'domain1Neg': 0, 'domain2Neg': 0, 'domain3Neg': 0, 'domain4Neg': 0}
        # Initialize data dictionary
        data_dict = {}
        for domain_num in range(1, 5):
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'trForGammarPos', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'trForGammarNeg', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'trForVrPos', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'trForVrNeg', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'trForDr', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'trForTrajPos', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'trForTrajNeg', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'gammarPos', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'gammarPos_err', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'gammarNeg', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'gammarNeg_err', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'cxmaxlist', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'cymaxlist', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'cxminlist', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'cyminlist', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'gammarPosForCore', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'gammarNegForCore', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'vrPos', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'vrNeg', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'dr', [])
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'terminatePos', False)
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'terminateNeg', False)
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'good_corePos', False)
            data_dict = update_data_dict(data_dict, "domain{0}".format(domain_num), 'good_coreNeg', False)

        # Read PIVLab data of the corresponding cine, and compute circulation, ring vel, and diameter
        for i, f in enumerate(frames):
            # Convert frame to sec
            time.append(f / float(rate))

            if f % plot_spacing == 0:
                print '-----------------------------------------------------------'
                print 'Processing frame %d' % f
                print 'image size in px (y,x): ', imsize
                try:
                    i += frames[0] / frame_spacing
                except TypeError:
                    print 'NO FRAME SPACING SPECIFIED! EXITING'
                # Read data from txt files generated by PIVLab
                print 'Attempting to read the txt data from...:'
                print os.path.join(data_dir, 'D%04d.txt' % f)

                if os.path.exists(os.path.join(data_dir, 'D%06d.txt' % f)):
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, 'D%06d.txt' % f))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, 'D%06d.txt' % f))
                    print 'Loaded D%06d.txt' % f
                elif os.path.exists(os.path.join(data_dir, 'D%05d.txt' % f)):
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, 'D%05d.txt' % f))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, 'D%05d.txt' % f))
                    print 'Loaded D%05d.txt' % f
                elif os.path.exists(os.path.join(data_dir, 'D%04d.txt' % f)):
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, 'D%04d.txt' % f))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, 'D%04d.txt' % f))
                    print '...Loaded D%04d.txt' % f
                elif os.path.exists(os.path.join(data_dir, 'D%03d.txt' % f)):
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, 'D%03d.txt' % f))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, 'D%03d.txt' % f))
                    print '...Loaded D%03d.txt' % f
                elif os.path.exists(os.path.join(data_dir, 'D%02d.txt' % f)):
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, 'D%02d.txt' % f))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, 'D%02d.txt' % f))
                    print '...Loaded D%02d.txt' % f
                elif os.path.exists(os.path.join(data_dir, 'D%01d.txt' % f)):
                    if omegabool:
                        x, y, ux, uy, omega = load_matlab_data(os.path.join(data_dir, 'D%01d.txt' % f))
                    else:
                        x, y, ux, uy = load_matlab_data(os.path.join(data_dir, 'D%01d.txt' % f))
                    print '...Loaded D%01d.txt' % f
                else:
                    print 'NO DATA EXISTS FOR FRAME: %d; SKIPPING!' % f


                #Clean data by excluding unreasonable values and linearly interpolating excluded data points
                print '---------------'
                print 'Cleaning ux... cutoff is ' + str(cutoffu * scale * rate) + 'mm/s'
                ux = process.clean_multi_dim_array(ux, cutoff=cutoffu, verbose=False)
                print 'Cleaning uy... cutoff is ' + str(cutoffu * scale * rate) + 'mm/s'
                uy = process.clean_multi_dim_array(uy, cutoff=cutoffu, verbose=False)
                print 'Cleaning omega... cutoff is ' + str(cutoffomega * rate) + '1/s'
                omega = process.clean_multi_dim_array(omega, cutoff=cutoffomega, verbose=False)
                print '---------------'

                # Figure out the dimension of 2D data (nx, ny)
                nx, ny = (x[-1] - x[0]) * 2 / box_size + 1, (y[-1] - y[0]) * 2 / box_size + 1

                # Reshape data into 2d array(ny, nx)
                xgrid = np.array(x).reshape((ny, nx))
                ygrid = np.array(y).reshape((ny, nx))
                omegagrid = np.array(omega).reshape((ny, nx))
                uxgrid = np.array(ux).reshape((ny, nx))
                uygrid = np.array(uy).reshape((ny, nx))

                # COMPUTE INTERPOLATED VELOCITY AND VORTICITY
                # CONVERT PX -> MM AND FRAME -> SEC
                Xgrid, Ygrid, iuxgrid = interp_flow_component(x * scale, y * scale, ux * scale * rate)
                Xgrid, Ygrid, iuygrid = interp_flow_component(x * scale, y * scale, uy * scale * rate)
                Xgrid, Ygrid, iomegagrid = interp_flow_component(x * scale, y * scale, omega * rate)
                nrows, ncolumns = Xgrid.shape
                xmin, xmax, ymin, ymax = min(Xgrid.flatten()), max(Xgrid.flatten()),\
                                         min(Ygrid.flatten()), max(Ygrid.flatten())
                width, height = xmax - xmin, ymax - ymin
                print 'Window dimension in mm: (xmin, xmax, ymin, ymax)=(%.2f, %.2f, %.2f, %.2f)'\
                      % (xmin, xmax, ymin, ymax)

                # VORTEX CORE DETECTION
                redo = True
                while redo:
                    redo_list = []
                    if not use_roi:
                        # # # Divide the interpolated grids into four domains
                        ################################
                        #        -> x
                        #   |           rx        1-rx
                        # y v       <---------><--------->
                        #        ^ | Domain 1 | Domain 3 |
                        #     ry | |          |          |
                        #        v  _____________________
                        #        ^ |          |          |
                        #  1-ry  | |          |          |
                        #        v | Domain 2 | Domain 4 |
                        ################################4
                        Xgrid1, Xgrid2, Xgrid3, Xgrid4 = fa.divide_2d_array_into_four_domains(Xgrid, rx=rx, ry=ry)
                        Ygrid1, Ygrid2, Ygrid3, Ygrid4 = fa.divide_2d_array_into_four_domains(Ygrid, rx=rx, ry=ry)
                        iomegagrid1, iomegagrid2, iomegagrid3, iomegagrid4 = fa.divide_2d_array_into_four_domains(iomegagrid, rx=rx, ry=ry)


                        # Find how many points in the interpolated velocity/vorticity field correspond to the data at the edges
                        nxedges = 1 + int(np.abs(xgrid[1][0] - xgrid[0][0]) / 2 * scale / __xint__)
                        nyedges = 1 + int(np.abs(ygrid[0][1] - ygrid[0][0]) / 2 * scale / __yint__)
                        print 'Number of points ignored from the horizontal and vertical edges: ', nxedges, nyedges

                        # Exclude vorticity data at the edges
                        iomegagrid_no_edges = iomegagrid[nyedges:-nyedges, nxedges:-nxedges]
                        Xgrid_no_edges = Xgrid[nyedges:-nyedges, nxedges:-nxedges]
                        Ygrid_no_edges = Ygrid[nyedges:-nyedges, nxedges:-nxedges]

                        iomegagrid1_no_edges, iomegagrid2_no_edges = iomegagrid1[nyedges:, nxedges:], iomegagrid2[:-nyedges, nxedges:]
                        iomegagrid3_no_edges, iomegagrid4_no_edges = iomegagrid3[nyedges:, :-nxedges], iomegagrid4[:-nyedges,: -nxedges]
                        Xgrid1_no_edges, Xgrid2_no_edges = Xgrid1[nyedges:, nxedges:], Xgrid2[:-nyedges, nxedges:]
                        Xgrid3_no_edges, Xgrid4_no_edges = Xgrid3[nyedges:, :-nxedges], Xgrid4[:-nyedges, :-nxedges]
                        Ygrid1_no_edges, Ygrid2_no_edges = Ygrid1[nyedges:, nxedges:], Ygrid2[:-nyedges, nxedges:]
                        Ygrid3_no_edges, Ygrid4_no_edges = Ygrid3[nyedges:, :-nxedges], Ygrid4[:-nyedges, :-nxedges]

                        # Find the maximum/minimum value of vorticity in each domain
                        iomegamax1 = max(iomegagrid1_no_edges.flatten())
                        iomegamin1 = min(iomegagrid1_no_edges.flatten())
                        iomegamax2 = max(iomegagrid2_no_edges.flatten())
                        iomegamin2 = min(iomegagrid2_no_edges.flatten())
                        iomegamax3 = max(iomegagrid3_no_edges.flatten())
                        iomegamin3 = min(iomegagrid3_no_edges.flatten())
                        iomegamax4 = max(iomegagrid4_no_edges.flatten())
                        iomegamin4 = min(iomegagrid4_no_edges.flatten())


                        # Find a position of maximum/minimum vorticity in each quadrant
                        max_y1, max_x1 = np.where(iomegagrid == iomegamax1)
                        min_y1, min_x1 = np.where(iomegagrid == iomegamin1)
                        max_y2, max_x2 = np.where(iomegagrid == iomegamax2)
                        min_y2, min_x2 = np.where(iomegagrid == iomegamin2)
                        max_y3, max_x3 = np.where(iomegagrid == iomegamax3)
                        min_y3, min_x3 = np.where(iomegagrid == iomegamin3)
                        max_y4, max_x4 = np.where(iomegagrid == iomegamax4)
                        min_y4, min_x4 = np.where(iomegagrid == iomegamin4)


                        print 'Quadrant1: Position of maximum/minimum omega in mm: (%.2f, %.2f), (%.2f, %.2f)'\
                            % (Xgrid[int(max_y1), int(max_x1)], Ygrid[int(max_y1), int(max_x1)],
                               Xgrid[int(min_y1), int(min_x1)], Ygrid[int(min_y1), int(min_x1)])
                        print 'Quadrant2: Position of maximum/minimum omega in mm: (%.2f, %.2f), (%.2f, %.2f)'\
                            % (Xgrid[int(max_y2), int(max_x2)], Ygrid[int(max_y2), int(max_x2)],
                               Xgrid[int(min_y2), int(min_x2)], Ygrid[int(min_y2), int(min_x2)])
                        print 'Quadrant3: Position of maximum/minimum omega in mm: (%.2f, %.2f), (%.2f, %.2f)'\
                            % (Xgrid[int(max_y3), int(max_x3)], Ygrid[int(max_y3), int(max_x3)],
                               Xgrid[int(min_y3), int(min_x3)], Ygrid[int(min_y3), int(min_x3)])
                        print 'Quadrant4: Position of maximum/minimum omega in mm: (%.2f, %.2f), (%.2f, %.2f)'\
                            % (Xgrid[int(max_y4), int(max_x4)], Ygrid[int(max_y4), int(max_x4)],
                               Xgrid[int(min_y4), int(min_x4)], Ygrid[int(min_y4), int(min_x4)])



                        # Extract a fraction of vorticity data around a position of maximum/minimum vorticity
                        # Unless the cores are near the edge, it gets grids with dimension (nx_frac * 2 + 1, ny_frac * 2 + 1)

                        Xgrid_around_max1, Ygrid_around_max1, iomegagrid_around_max1 = get_small_grids_around_coord(iomegagrid, Xgrid, Ygrid, max_x1, max_y1, nx_frac, ny_frac)
                        Xgrid_around_min1, Ygrid_around_min1, iomegagrid_around_min1 = get_small_grids_around_coord(iomegagrid, Xgrid, Ygrid, min_x1, min_y1, nx_frac, ny_frac)
                        Xgrid_around_max2, Ygrid_around_max2, iomegagrid_around_max2 = get_small_grids_around_coord(iomegagrid, Xgrid, Ygrid, max_x2, max_y2, nx_frac, ny_frac)
                        Xgrid_around_min2, Ygrid_around_min2, iomegagrid_around_min2 = get_small_grids_around_coord(iomegagrid, Xgrid, Ygrid, min_x2, min_y2, nx_frac, ny_frac)
                        Xgrid_around_max3, Ygrid_around_max3, iomegagrid_around_max3 = get_small_grids_around_coord(iomegagrid, Xgrid, Ygrid, max_x3, max_y3, nx_frac, ny_frac)
                        Xgrid_around_min3, Ygrid_around_min3, iomegagrid_around_min3 = get_small_grids_around_coord(iomegagrid, Xgrid, Ygrid, min_x3, min_y3, nx_frac, ny_frac)
                        Xgrid_around_max4, Ygrid_around_max4, iomegagrid_around_max4 = get_small_grids_around_coord(iomegagrid, Xgrid, Ygrid, max_x4, max_y4, nx_frac, ny_frac)
                        Xgrid_around_min4, Ygrid_around_min4, iomegagrid_around_min4 = get_small_grids_around_coord(iomegagrid, Xgrid, Ygrid, min_x4, min_y4, nx_frac, ny_frac)



                        # Find ring core positions through the center of vorticity algorithm
                        # Note that assigning the center of vorticity fails if the region contains the opposite voriticity
                        # In such a case, the core position is recorded as (0, 0)
                        max_xw1, max_yw1 = ndimage.measurements.center_of_mass(iomegagrid_around_max1)   # these are indices (decimal)
                        min_xw1, min_yw1 = ndimage.measurements.center_of_mass(iomegagrid_around_min1)   # these are indices (decimal)
                        max_xw2, max_yw2 = ndimage.measurements.center_of_mass(iomegagrid_around_max2)   # these are indices (decimal)
                        min_xw2, min_yw2 = ndimage.measurements.center_of_mass(iomegagrid_around_min2)   # these are indices (decimal)
                        max_xw3, max_yw3 = ndimage.measurements.center_of_mass(iomegagrid_around_max3)   # these are indices (decimal)
                        min_xw3, min_yw3 = ndimage.measurements.center_of_mass(iomegagrid_around_min3)   # these are indices (decimal)
                        max_xw4, max_yw4 = ndimage.measurements.center_of_mass(iomegagrid_around_max4)   # these are indices (decimal)
                        min_xw4, min_yw4 = ndimage.measurements.center_of_mass(iomegagrid_around_min4)   # these are indices (decimal)


                        # Track a position of vortex ring core of positive/negative vorticity
                        # When the center of vorticity calculation fails, it assigns (0, 0) as
                        cx_max_dict, cy_max_dict, cx_min_dict, cy_min_dict = {}, {}, {}, {}
                        cx_max_dict["domain1"] = fa.get_values_from_multidim_array_at_coord(Xgrid_around_max1, max_xw1, max_yw1)
                        cy_max_dict["domain1"] = fa.get_values_from_multidim_array_at_coord(Ygrid_around_max1, max_xw1, max_yw1)
                        cx_max_dict["domain2"] = fa.get_values_from_multidim_array_at_coord(Xgrid_around_max2, max_xw2, max_yw2)
                        cy_max_dict["domain2"] = fa.get_values_from_multidim_array_at_coord(Ygrid_around_max2, max_xw2, max_yw2)
                        cx_max_dict["domain3"] = fa.get_values_from_multidim_array_at_coord(Xgrid_around_max3, max_xw3, max_yw3)
                        cy_max_dict["domain3"] = fa.get_values_from_multidim_array_at_coord(Ygrid_around_max3, max_xw3, max_yw3)
                        cx_max_dict["domain4"] = fa.get_values_from_multidim_array_at_coord(Xgrid_around_max4, max_xw4, max_yw4)
                        cy_max_dict["domain4"] = fa.get_values_from_multidim_array_at_coord(Ygrid_around_max4, max_xw4, max_yw4)
                        cx_min_dict["domain1"] = fa.get_values_from_multidim_array_at_coord(Xgrid_around_min1, min_xw1, min_yw1)
                        cy_min_dict["domain1"] = fa.get_values_from_multidim_array_at_coord(Ygrid_around_min1, min_xw1, min_yw1)
                        cx_min_dict["domain2"] = fa.get_values_from_multidim_array_at_coord(Xgrid_around_min2, min_xw2, min_yw2)
                        cy_min_dict["domain2"] = fa.get_values_from_multidim_array_at_coord(Ygrid_around_min2, min_xw2, min_yw2)
                        cx_min_dict["domain3"] = fa.get_values_from_multidim_array_at_coord(Xgrid_around_min3, min_xw3, min_yw3)
                        cy_min_dict["domain3"] = fa.get_values_from_multidim_array_at_coord(Ygrid_around_min3, min_xw3, min_yw3)
                        cx_min_dict["domain4"] = fa.get_values_from_multidim_array_at_coord(Xgrid_around_min4, min_xw4, min_yw4)
                        cy_min_dict["domain4"] = fa.get_values_from_multidim_array_at_coord(Ygrid_around_min4, min_xw4, min_yw4)
                        cy_min_dict["domain4"] = fa.get_values_from_multidim_array_at_coord(Ygrid_around_min4, min_xw4, min_yw4)

                        # If the detected core (centr of vorticity) is not in the proper quadrant, set the core position as nan
                        for domain_num in range(1, 5):
                            cx_max, cy_max = cx_max_dict["domain{0}".format(domain_num)][0], cy_max_dict["domain{0}".format(domain_num)][0]
                            cx_min, cy_min = cx_min_dict["domain{0}".format(domain_num)][0], cy_min_dict["domain{0}".format(domain_num)][0]
                            quads = make_quadrants(xmin, xmax, ymin, ymax, rx, ry)
                            if not quads[domain_num-1].contains_point((cx_max, cy_max)) or (cx_max_dict["domain{0}".format(domain_num)] == 0 and cy_max_dict["domain{0}".format(domain_num)] == 0):
                                cx_max_dict["domain{0}".format(domain_num)], cy_max_dict["domain{0}".format(domain_num)] = np.array([np.nan]), np.array([np.nan])
                            if not quads[domain_num - 1].contains_point((cx_min, cy_min)) or (cx_min_dict["domain{0}".format(domain_num)] == 0 and cy_min_dict["domain{0}".format(domain_num)] == 0):
                                cx_min_dict["domain{0}".format(domain_num)], cy_min_dict["domain{0}".format(domain_num)] = np.array([np.nan]), np.array([np.nan])
                            print 'Quadrant%d: Vortex ring core position (+,-) in mm: (%.2f, %.2f), (%.2f, %.2f)' % (domain_num,
                                                                                                                     cx_max_dict["domain{0}".format(domain_num)],
                                                                                                                     cy_max_dict["domain{0}".format(domain_num)],
                                                                                                                     cx_min_dict["domain{0}".format(domain_num)],
                                                                                                                     cy_min_dict["domain{0}".format(domain_num)])
                            # d = compute_dist(cx_max, cy_max, cx_min, cy_min)
                            # use_roi_list = [False, False, False, False]
                        #    # Go into Roi Mode if the detected cores are too close to each other.
                        #     if d < d_thd_opp_core:
                        #         use_roi_list[domain_num-1] = True
                        #         print 'Detected cores are too close to each other. Check '
                        # if any(use_roi_list):
                        #     use_roi = True
                        # else:
                        #     use_roi = False



                        # If cores are about to leave the associated quadrants, plot vorticity field
                        x_quad = xmin + width * rx
                        y_quad = ymin + height * ry

                        for domain_num in range(1, 5):
                            quads = make_quadrants(xmin, xmax, ymin, ymax, rx, ry)

                            # Get positions of detected cores at current frame
                            # These are actually lists with one element each. i.e.- cxmax = [float]
                            cxmax = cx_max_dict["domain{0}".format(domain_num)]
                            cymax = cy_max_dict["domain{0}".format(domain_num)]
                            cxmin = cx_min_dict["domain{0}".format(domain_num)]
                            cymin = cy_min_dict["domain{0}".format(domain_num)]
                            core_positions = [[cxmax, cymax], [cxmin, cymin]]
                            vorticity_sign = ['+', '-']

                            for j, core_position in enumerate(core_positions):
                                cx, cy = core_position[0], core_position[1]
                                # Redefine quadrants if the quadrant algorithm still works
                                if np.abs(x_quad - cx) < width * core_check_thd:
                                    Xgrid_around_core, Ygrid_around_core, iomegagrid_around_core = get_small_grids_around_coord(iomegagrid, Xgrid, Ygrid, cx, cy, nx_frac, ny_frac)
                                    gamma_temp = iomegagrid_around_core.sum()
                                    print 'gamma_temp: %f' %gamma_temp
                                    if gamma_temp > gamma_thd:
                                        print 'REDEFINE QUADRANTS: rx! ACTIVATE ROI MODE BY CLICKING WHILE PRESSING r.' \
                                              ' OTHERS: t: TERMINATE, p: PASS, d: REDO CORE DETECTION'
                                        plt.imshow(iomegagrid, cmap=cmap2, vmin=-w_limit, vmax=w_limit, interpolation='gaussian',
                                                   extent=(xmin, xmax, ymax, ymin))
                                        plt.scatter(core_position[0], core_position[1], marker='x', c='k')
                                        plt.title(
                                            'f=%d, Quadrant%d (%s): Click a point to redefine rx' % (f, domain_num, vorticity_sign[j]))
                                        fig, ax = plt.gcf(), plt.gca()
                                        draw_quadrants(ax, rx, ry)
                                        cid = fig.canvas.mpl_connect('button_press_event', redefine_rx)
                                        plt.show()
                                        redo_list.append(redo)
                                    else:
                                        if j == 0:
                                            cxmax, cymax = np.array([np.nan]), np.array([np.nan])
                                        elif j == 1:
                                            cxmin, cymin = np.array([np.nan]), np.array([np.nan])
                                        redo_list.append(False)
                                elif np.abs(y_quad - cy) < height * core_check_thd:
                                    Xgrid_around_core, Ygrid_around_core, iomegagrid_around_core = get_small_grids_around_coord(iomegagrid, Xgrid, Ygrid, cx, cy, nx_frac, ny_frac)
                                    gamma_temp = iomegagrid_around_core.sum()
                                    print 'gamma_temp: %f' %gamma_temp
                                    if gamma_temp > gamma_thd:
                                        print 'REDEFINE QUADRANTS: ry! ACTIVATE ROI MODE BY CLICKING WHILE PRESSING r.' \
                                              ' OTHERS: t: TERMINATE, p: PASS, d: REDO CORE DETECTION'
                                        plt.imshow(iomegagrid, cmap=cmap2, vmin=-w_limit, vmax=w_limit, interpolation='gaussian',
                                                   extent=(xmin, xmax, ymax, ymin))
                                        plt.scatter(core_position[0], core_position[1], marker='x', c='k')
                                        plt.title('f=%d, Quadrant%d (%s): Click a point to redefine ry' % (f, domain_num, vorticity_sign[j]))
                                        fig, ax = plt.gcf(), plt.gca()
                                        draw_quadrants(ax, rx, ry)

                                        cid = fig.canvas.mpl_connect('button_press_event', redefine_ry)
                                        plt.show()
                                        redo_list.append(redo)
                                    else:
                                        if j == 0:
                                            cxmax, cymax = np.array([np.nan]), np.array([np.nan])
                                        elif j == 1:
                                            cxmin, cymin = np.array([np.nan]), np.array([np.nan])
                                        redo_list.append(False)
                                else:
                                    redo_list.append(False)
                            # For the last quadrant, decide if we redo the core detection algorithm with new rx and ry
                            if domain_num == 4:
                                if any(redo_list): redo = True
                                else: redo = False

                            # # For 20180513 Data, set exceptions to use ROI mode from the beginning
                            # if ((span == 15.7 or span == 18.4 or span == 21.0) and vp_c == 400)\
                            #     or ((span == 13.1 or span == 18.4 or span == 21.0) and vp_c == 1000) \
                            #     or (span == 15.7 and vp_c == 200):
                            #     use_roi = True
                            #     redo = True

                                ## Show detected cores in the plot every frame
                                # plt.imshow(iomegagrid, cmap=cmap2, vmin=-w_limit, vmax=w_limit, interpolation='gaussian',
                                #            extent=(xmin, xmax, ymax, ymin))
                                # plt.title('f=%d: Check all cores detected' % f)
                                # colors2 = ['k', 'c', 'm', 'y']
                                # for domain_num_local in range(1, 5):
                                #     # Get positions of detected cores at current frame
                                #     cxmax = cx_max_dict["domain{0}".format(domain_num_local)]
                                #     cymax = cy_max_dict["domain{0}".format(domain_num_local)]
                                #     cxmin = cx_min_dict["domain{0}".format(domain_num_local)]
                                #     cymin = cy_min_dict["domain{0}".format(domain_num_local)]
                                #     core_positions = [[cxmax, cymax], [cxmin, cymin]]
                                #     for jj, core_position_local in enumerate(core_positions):
                                #         if (jj == 0 and not data_dict["domain{0}".format(domain_num_local)]['terminatePos']) or (
                                #                 jj == 1 and not data_dict["domain{0}".format(domain_num_local)]['terminateNeg']):
                                #             plt.scatter(core_position_local[0], core_position_local[1], marker='x',
                                #                         c=colors2[domain_num_local - 1])
                                # fig = plt.gcf()
                                # cid = fig.canvas.mpl_connect('key_press_event', check_cores)
                                # plt.show()
                    # ROI MODE
                    else:
                        print 'DRAW A RECTANGLE ENCLOSING CORE. ' \
                              'PRESS c TO EXIT.' \
                              'PRESS n IF THE CORE IS NOT IN THE WINDOW OR IS UNDETECTABLE'
                        for domain_num in range(1, 5):
                            quads = make_quadrants(xmin, xmax, ymin, ymax, rx, ry)

                            # Get positions of detected cores at current frame
                            cxmax = cx_max_dict["domain{0}".format(domain_num)]
                            cymax = cy_max_dict["domain{0}".format(domain_num)]
                            cxmin = cx_min_dict["domain{0}".format(domain_num)]
                            cymin = cy_min_dict["domain{0}".format(domain_num)]
                            core_positions = [[cxmax, cymax], [cxmin, cymin]]
                            vorticity_sign = ['+', '-']

                            for j, core_position in enumerate(core_positions):
                                cx, cy = core_position[0], core_position[1]
                                plt.imshow(iomegagrid, cmap=cmap2, vmin=-w_limit, vmax=w_limit, interpolation='gaussian',
                                           extent=(xmin, xmax, ymax, ymin))
                                plt.scatter(core_position[0], core_position[1], marker='x', c='k')
                                plt.title('f=%d, Quadrant%d (%s): Draw a rectangle which includes the core.' % (f, domain_num, vorticity_sign[j]))
                                fig, ax = plt.gcf(), plt.gca()
                                draw_quadrants(ax, rx, ry)
                                toggle_selector.RS = RectangleSelector(ax, line_select_callback,
                                                                       drawtype='box', useblit=True,
                                                                       button=[1, 3],  # don't use middle button
                                                                       minspanx=5, minspany=5,
                                                                       spancoords='pixels',
                                                                       interactive=True)
                                plt.connect('key_press_event', toggle_selector)
                                plt.show()

                                # Now, get Xgrid, Ygrid, iomegagrid in the rectangle
                                #global rec_x_ini, rec_y_ini, rec_x_fin, rec_y_fin
                                #print rec_x_ini, rec_y_ini, rec_x_fin, rec_y_fin
                                xmin_ind, value = fa.find_nearest(Xgrid[0], rec_x_ini, option='normal')
                                xmax_ind, value = fa.find_nearest(Xgrid[0], rec_x_fin, option='normal')
                                ymin_ind, value = fa.find_nearest(Ygrid[..., 0], rec_y_ini, option='normal')
                                ymax_ind, value = fa.find_nearest(Ygrid[..., 0], rec_y_fin, option='normal')

                                Xgrid_rec, Ygrid_rec, iomegagrid_rec = Xgrid[ymin_ind:ymax_ind, xmin_ind:xmax_ind], Ygrid[ymin_ind:ymax_ind, xmin_ind:xmax_ind], iomegagrid[ymin_ind:ymax_ind, xmin_ind:xmax_ind]
                                # Find the center of vorticirty (cov)
                                x_cov, y_cov = ndimage.measurements.center_of_mass(iomegagrid_rec)  # these are indices (decimal)
                                if is_core_in_window:
                                    if j == 0:
                                        cx_max_dict["domain{0}".format(domain_num)][0] = fa.get_values_from_multidim_array_at_coord(Xgrid_rec, x_cov, y_cov)
                                        cy_max_dict["domain{0}".format(domain_num)][0] = fa.get_values_from_multidim_array_at_coord(Ygrid_rec, x_cov, y_cov)
                                        #print 'Quadrant%d: Vortex ring core position (+) in mm: (%.2f, %.2f)' % (domain_num, cx_max_dict["domain{0}".format(domain_num)], cy_max_dict["domain{0}".format(domain_num)])
                                    elif j == 1:
                                        cx_min_dict["domain{0}".format(domain_num)][0] = fa.get_values_from_multidim_array_at_coord(Xgrid_rec, x_cov, y_cov)
                                        cy_min_dict["domain{0}".format(domain_num)][0] = fa.get_values_from_multidim_array_at_coord(Ygrid_rec, x_cov, y_cov)
                                        #print 'Quadrant%d: Vortex ring core position (-) in mm: (%.2f, %.2f)' % (domain_num, cx_min_dict["domain{0}".format(domain_num)], cy_min_dict["domain{0}".format(domain_num)])
                                else:
                                    if j == 0:
                                        cx_max_dict["domain{0}".format(domain_num)][0], cy_max_dict["domain{0}".format(domain_num)][0] = np.array([np.nan]), np.array([np.nan])
                                        #print 'Quadrant%d: Vortex ring core position (+) in mm: (%.2f, %.2f)' % (domain_num, cx_max_dict["domain{0}".format(domain_num)], cy_max_dict["domain{0}".format(domain_num)])
                                    elif j == 1:
                                        cx_min_dict["domain{0}".format(domain_num)][0], cy_min_dict["domain{0}".format(domain_num)][0] = np.array([np.nan]), np.array([np.nan])
                                    is_core_in_window = True

                        # CHECK ALL CORES
                        # If redo was necessary, press r in the plot.
                        colors2 = ['k', 'c', 'm', 'y']
                        plt.imshow(iomegagrid, cmap=cmap2, vmin=-w_limit, vmax=w_limit, interpolation='gaussian',
                                   extent=(xmin, xmax, ymax, ymin))
                        plt.title('f=%d: Check all cores detected' % f)
                        for domain_num in range(1, 5):
                            cxmax = cx_max_dict["domain{0}".format(domain_num)]
                            cymax = cy_max_dict["domain{0}".format(domain_num)]
                            cxmin = cx_min_dict["domain{0}".format(domain_num)]
                            cymin = cy_min_dict["domain{0}".format(domain_num)]
                            core_positions = [[cxmax, cymax], [cxmin, cymin]]
                            vorticity_sign = ['+', '-']
                            for j, core_position in enumerate(core_positions):
                                #print core_position
                                cx, cy = core_position[0], core_position[1]
                                plt.imshow(iomegagrid, cmap=cmap2, vmin=-w_limit, vmax=w_limit, interpolation='gaussian',
                                           extent=(xmin, xmax, ymax, ymin))
                                plt.scatter(core_position[0], core_position[1], marker='x', c=colors2[domain_num-1])
                        fig = plt.gcf()
                        cid = fig.canvas.mpl_connect('key_press_event', check_cores)
                        plt.show()

                    # MAIN COMPUTATION ENDS HERE. REDO the core detection and computation
                    print 'REDO: %r' % redo
                    if terminate: break


                # Compute distances between neighbor cores
                if not cx_max_dict["domain1"][0] == np.nan and not cx_min_dict["domain2"][0] == np.nan:
                    d12 = compute_dist(cx_max_dict["domain1"], cy_max_dict["domain1"],
                                       cx_min_dict["domain2"], cy_min_dict["domain2"])
                else:
                    d12 = np.nan
                if not cx_min_dict["domain1"][0] == np.nan and not cx_max_dict["domain3"][0] == np.nan:
                    d13 = compute_dist(cx_min_dict["domain1"], cy_min_dict["domain1"],
                                       cx_max_dict["domain3"], cy_max_dict["domain3"])
                else:
                    d13 = np.nan
                if not cx_max_dict["domain2"][0] == np.nan and not cx_min_dict["domain4"][0] == np.nan:
                    d24 = compute_dist(cx_max_dict["domain2"], cy_max_dict["domain2"],
                                       cx_min_dict["domain4"], cy_min_dict["domain4"])
                else:
                    d24 = np.nan
                if not cx_min_dict["domain3"][0] == np.nan and not cx_max_dict["domain4"][0] == np.nan:
                    d34 = compute_dist(cx_min_dict["domain3"], cy_min_dict["domain3"],
                                       cx_max_dict["domain4"], cy_max_dict["domain4"])
                else:
                    d34 = np.nan

                d12_list.append(d12)
                d13_list.append(d13)
                d24_list.append(d24)
                d34_list.append(d34)


                ###############################################################
                # UPDATE DATADICT ABOUT CORE POSITIONS IN THE CURRENT FRAME
                for domain_num in range(1, 5):
                    print '+++++++++++++++++++++++++++++++++'
                    # Get positions of detected cores at current frame
                    cxmax = cx_max_dict["domain{0}".format(domain_num)]
                    cymax = cy_max_dict["domain{0}".format(domain_num)]
                    cxmin = cx_min_dict["domain{0}".format(domain_num)]
                    cymin = cy_min_dict["domain{0}".format(domain_num)]
                    core_positions = [[cxmax, cymax], [cxmin, cymin]]
                    for j, core_position in enumerate(core_positions):
                        if j == 0:  # Positive core
                            trForTraj = data_dict["domain{0}".format(domain_num)]["trForTrajPos"]
                            # trForVr = data_dict["domain{0}".format(domain_num)]["trForVrPos"]
                            # Refer to lists of core positions
                            cxmaxlist = data_dict["domain{0}".format(domain_num)]["cxmaxlist"]
                            cymaxlist = data_dict["domain{0}".format(domain_num)]["cymaxlist"]
                            # vr = data_dict["domain{0}".format(domain_num)]['vrPos']
                            # counter = counter_dict["domain{0}Pos".format(domain_num)]
                            # Append core positions in the current frame to the list
                            trForTraj.append(f / float(rate))
                            # trForVr.append(f / float(rate))
                            cxmaxlist.append(cx_max_dict["domain{0}".format(domain_num)][0])
                            cymaxlist.append(cy_max_dict["domain{0}".format(domain_num)][0])
                            # if len(trForVr) > 1:
                            #     vr.append(compute_dist(cxminlist[counter], cyminlist[counter], cxminlist[counter - vrtimestep], cyminlist[counter - vrtimestep])
                            #                           / (trForVr[counter / vrtimestep - 1] - trForVr[counter / vrtimestep - 2]))

                        elif j == 1:  # Negative core
                            trForTraj = data_dict["domain{0}".format(domain_num)]["trForTrajNeg"]
                            # trForVr = data_dict["domain{0}".format(domain_num)]["trForVrNeg"]
                            # Refer to lists of core positions
                            cxminlist = data_dict["domain{0}".format(domain_num)]["cxminlist"]
                            cyminlist = data_dict["domain{0}".format(domain_num)]["cyminlist"]
                            # vr = data_dict["domain{0}".format(domain_num)]['vrNeg']
                            # counter = counter_dict["domain{0}Neg".format(domain_num)]
                            # Append core positions in the current frame to the list
                            trForTraj.append(f / float(rate))
                            # trForVr.append(f / float(rate))
                            cxminlist.append(cx_min_dict["domain{0}".format(domain_num)][0])
                            cyminlist.append(cy_min_dict["domain{0}".format(domain_num)][0])
                            # counter_dict["domain{0}Neg".format(domain_num)] = counter_dict[
                            #                                                   "domain{0}Neg".format(domain_num)] + 1


                    # COMPUTE RING DIAMETER
                    trForDr = data_dict["domain{0}".format(domain_num)]['trForDr']
                    dr = data_dict["domain{0}".format(domain_num)]['dr']
                    try:
                        dri = compute_dist(cx_max_dict["domain{0}".format(domain_num)],
                                           cy_max_dict["domain{0}".format(domain_num)],
                                           cx_min_dict["domain{0}".format(domain_num)],
                                           cy_min_dict["domain{0}".format(domain_num)])
                        # Update diameter and time arrays
                        trForDr.append(f / float(rate))
                        dr.append(dri)
                        print 'Quadrant%d: dr=%.2f' % (domain_num, dri)
                        # print trForDr, dr
                        # print 'Diameter: %.2f, %d, %d' % (dri, f, domain_num)
                    except IndexError:
                        print 'One of vortex ring cores was not found. Cannot compute ring diameter for the quadrant %d' % domain_num
                        continue
                ###############################################################



                ###### CIRCULATION/VELOCITY/DIAMETER COMPUTATION ###########
                gammas_for_check = []
                for domain_num in range(1, 5):
                    # Get detected core positions in each domain
                    cxmax = cx_max_dict["domain{0}".format(domain_num)]
                    cymax = cy_max_dict["domain{0}".format(domain_num)]
                    cxmin = cx_min_dict["domain{0}".format(domain_num)]
                    cymin = cy_min_dict["domain{0}".format(domain_num)]

                    core_positions = [[cxmax, cymax], [cxmin, cymin]]
                    vorticity_sign = ['positive', 'negative']
                    for j, core_position in enumerate(core_positions):  #j=0: positive core, j=1: negative core
                        if (j == 0 and not data_dict["domain{0}".format(domain_num)]['terminatePos']) or (j == 1 and not data_dict["domain{0}".format(domain_num)]['terminateNeg']):
                            cx, cy = core_position[0], core_position[1]

                            # Check if integral paths are inside the image
                            bad_x_path = False
                            path_x_limits = radii[-1] * np.cos(phi) + cx  # in mm
                            bad_y_path = False
                            path_y_limits = radii[-1] * np.sin(phi) + cy  # in mm
                            cutoff = ((box_size / 2) + 1) * scale
                            # print '!!!!!!!!!!!!!!!!'
                            # print domain_num
                            # print cxmax, cymax
                            # print imsize[0], imsize[1]
                            # print imsize[0] * scale, cutoff
                            # print '!!!!!!!!!!!!!!!!'
                            if (path_y_limits <= cutoff).any() or (path_y_limits >= (imsize[0] * scale - cutoff)).any():
                                bad_y_path = True
                            if (path_x_limits <= cutoff).any() or (path_x_limits >= (imsize[1] * scale - cutoff)).any():
                                bad_x_path = True
                            if bad_x_path or bad_y_path:
                                if j == 0:
                                    gammarPosForCore = data_dict["domain{0}".format(domain_num)]["gammarPosForCore"]
                                    gammarPosForCore.append(np.nan)
                                elif j == 1:
                                    gammarNegForCore = data_dict["domain{0}".format(domain_num)]["gammarNegForCore"]
                                    gammarNegForCore.append(np.nan)
                                print 'Quadrant %d (%s): CIRCULATION CURVE NOT IN FRAME, SKIPPING' %(domain_num, vorticity_sign[j])
                                print '------------------------------'

                                continue

                            fig = plt.figure(figsize=(18, 14))
                            gs = gridspec.GridSpec(3, 3, width_ratios=[1, 1, 1], height_ratios=[1.5, 1, 2])

                            # iUx Plot
                            img1 = fig.add_subplot(gs[0])
                            #for r in radii:
                                #img1.plot(r * np.cos(phi) + cx, r * np.sin(phi) + cy, color=cmap(float(r) / float(max(radii))))
                            ax1 = img1.imshow(iuxgrid, cmap=cmap2, vmin=-ux_limit, vmax=ux_limit, interpolation='gaussian', \
                                              extent=(xmin, xmax, ymax, ymin))
                            draw_quadrants(img1, rx, ry)
                            img1.set_xlabel('X $[mm]$')
                            img1.set_ylabel('Y $[mm]$')
                            colorbar(ax1)

                            # iUy Plot
                            img2 = fig.add_subplot(gs[1])
                            #for r in radii:
                                #img2.plot(r * np.cos(phi) + cx, r * np.sin(phi) + cy, color=cmap(float(r) / float(max(radii))))
                            ax2 = img2.imshow(iuygrid, cmap=cmap2, vmin=-uy_limit, vmax=uy_limit, interpolation='gaussian', \
                                              extent=(xmin, xmax, ymax, ymin))
                            draw_quadrants(img2, rx, ry)
                            img2.set_xlabel('X $[mm]$')
                            img2.set_ylabel('Y $[mm]$')
                            colorbar(ax2)

                            # iOmega Plot
                            img3 = fig.add_subplot(gs[2])
                            for r in radii:
                                img3.plot(r * np.cos(phi) + cx, r * np.sin(phi) + cy, color=cmap(float(r) / float(max(radii))))
                            ax3 = img3.imshow(iomegagrid, cmap=cmap2, vmin=-w_limit, vmax=w_limit, interpolation='gaussian', \
                                              extent=(xmin, xmax, ymax, ymin))
                            draw_quadrants(img3, rx, ry)
                            img3.set_xlabel('X $[mm]$')
                            img3.set_ylabel('Y $[mm]$')
                            colorbar(ax3)

                            imgs = [img1, img2, img3]
                            titles = ['$u_x$ velocity $(mm/s)$', '$u_y$ velocity $(mm/s)$', '$\omega_z$ $(1/s)$']
                            for img, text in zip(imgs, titles):
                                # img.set_xlim([x[0], imsize[1] - x[0]])
                                # img.set_ylim([y[0], imsize[0] - y[0]])
                                # img.set_xticks([])
                                # img.set_yticks([])
                                img.set_title(text)
                                ax4 = plt.subplot(gs[3])
                                ax5 = plt.subplot(gs[4])
                                ax6 = plt.subplot(gs[5])
                                ax4.set_ylabel('velocity $(mm/s)$')

                            mean_gs = []
                            std_gs = []
                            for r in radii:
                                path_x, path_y = r * np.cos(phi) + cx, r * np.sin(phi) + cy
                                iux_p = ndimage.map_coordinates(iuxgrid, (path_y / __yint__, path_x / __xint__), order=1)
                                iuy_p = ndimage.map_coordinates(iuygrid, (path_y / __yint__, path_x / __xint__), order=1)

                                ax4.plot(phi, iux_p, color=cmap(float(r) / float(max(radii))))
                                ax5.plot(phi, iuy_p, color=cmap(float(r) / float(max(radii))))
                                ax6.plot(phi, -iux_p * np.sin(phi) + iuy_p * np.cos(phi),
                                         color=cmap(float(r) / float(max(radii))))

                                # CALCULATE AND PLOT CIRCULATIONS AND STATISTICS
                                gammas = []
                                ax7 = plt.subplot(gs[6:])
                                cm_shift_list = np.linspace(-cm_shift * scale, cm_shift * scale, num=10)
                                for off_i in cm_shift_list:
                                    for off_j in cm_shift_list:
                                        ds = 2 * np.pi * r / float(NP)
                                        path_x, path_y = r * np.cos(phi) + cx + off_i, r * np.sin(phi) + cy + off_j
                                        iux_p = ndimage.map_coordinates(iuxgrid, (path_y / __yint__, path_x / __xint__),
                                                                        order=1)
                                        iuy_p = ndimage.map_coordinates(iuygrid, (path_y / __yint__, path_x / __xint__),
                                                                        order=1)
                                        gammas.append(sum((-iux_p * np.sin(phi) + iuy_p * np.cos(phi)) * ds))

                                mean_g = np.mean(np.asarray(gammas))
                                mean_gs.append(mean_g)
                                std_g = np.std(np.asarray(gammas))
                                std_gs.append(std_g)

                                ax7.scatter(r, mean_g, color=cmap(float(r) / float(max(radii))), marker='o')
                                ax7.errorbar(r, mean_g, yerr=std_g, ecolor=cmap(float(r) / float(max(radii))),
                                             elinewidth=2)

                                axes = [ax4, ax5, ax6]
                                titles = ['$u_x$', '$u_y$', r'$u_\theta$']
                                for ax, text in zip(axes, titles):
                                    ax.set_title(text)
                                    ax.set_xlim([0, 2 * np.pi])
                                    ax.set_ylim([-ux_limit, ux_limit])
                                    ax.set_xticks((0, np.pi, 2 * np.pi))
                                    ax.set_xticklabels(('$0$', '$\pi$', '$2\pi$'))

                                # STORE ROBUST AND WEIGHTED AVERAGE CIRCULATION DATA
                                robust_g = mean_gs[np.argmin(np.asarray(std_gs))]
                                robust_r = radii[np.argmin(np.asarray(std_gs))]
                                weighted_avg = weighted_mean(mean_gs, std_gs)
                                weighted_avg_std = weighted_mean_std(std_gs)

                                ax7.set_xlabel('countour radius $(mm)$')
                                ax7.set_ylabel('circulation $(mm^2/s)$')
                                ax7.set_title('time: %.4f s' % (f / rate))
                                ax7.set_xlim([0, np.max(radii) + radii_diff])

                            # Prepare a dictionary with computed results. Save this file as a json file later
                            circulation_data = {'mean_gamma': list(mean_gs),
                                                'std_gamma': list(std_gs),
                                                'radii': list(radii),
                                                'weighted_avg': weighted_avg,
                                                'weighted_avg_std': weighted_avg_std}


                            print 'Quadrant%d(%s)- Circulation (weighted avg) in mm2/s: %s' %(domain_num, vorticity_sign[j], str(weighted_avg))

                            # Show results on plot
                            gammaavg = np.mean(mean_gs[-5:])
                            gammastd = np.mean(std_gs[-5:])
                            gammaplusstd = [mean_gs[i] + std_gs[i] for i in range(len(mean_gs))]
                            gammaminusstd = [mean_gs[i] - std_gs[i] for i in range(len(mean_gs))]
                            ybottom, ytop = ax7.get_ylim()
                            textposystep = np.abs(ytop-ybottom) / 10.

                            ax7.set_ylim([np.min(gammaminusstd), np.max(gammaplusstd)])
                            if j == 0:
                                text = 'highest $\Gamma_{avg}$: ' + str(np.max(mean_gs)) + ' $mm^2/s$'
                            elif j == 1:
                                text = 'lowest $\Gamma_{avg}$: ' + str(np.min(mean_gs)) + ' $mm^2/s$'
                            ax7.text(radii[-int(0.4 * sample_pts)], ybottom + textposystep * 4, text, fontsize=12)
                            text = 'average of last 5 values: ' + str(gammaavg) + ' $mm^2/s$'
                            ax7.text(radii[-int(0.4 * sample_pts)], ybottom + textposystep * 3, text, fontsize=12)
                            text = 'average of last 5 std : ' + str(gammastd) + ' $mm^2/s$'
                            ax7.text(radii[-int(0.4 * sample_pts)], ybottom + textposystep * 2, text, fontsize=12)

                            # Save data in json format
                            circulation_data_name = 'circulation_%06d_domain%d_%s.json' % (f, domain_num, vorticity_sign[j])
                            circulation_data_file = os.path.join(circulation_dir, circulation_data_name)
                            with open(circulation_data_file, 'w') as fyle:
                                print 'Saving... ' + circulation_data_file
                                json.dump(circulation_data, fyle, sort_keys=True, indent=1, separators=(',', ': '))
                                fyle.close()

                            # Save a plot in png
                            fig_name = 'circulation_%06d_domain%d_%s.png' % (f, domain_num, vorticity_sign[j])
                            fig_file = os.path.join(circulation_dir, fig_name)

                            if save_circ:
                                plt.savefig(fig_file)
                                print 'Saving...' + fig_file
                            #plt.show()
                            plt.close()


                            # Store values for time-revolution plot
                            # Refer these lists to lists stored in the data_dict  (NOTICE THAT THEY ARE NOT BEING COPIED!)
                            if j == 0: # j=0: Positive vorticity, j=1: Negative vorticity
                                trForGammar = data_dict["domain{0}".format(domain_num)]["trForGammarPos"]
                                trForVr = data_dict["domain{0}".format(domain_num)]["trForVrPos"]
                                gammar = data_dict["domain{0}".format(domain_num)]["gammarPos"]
                                gammar_err = data_dict["domain{0}".format(domain_num)]["gammarPos_err"]
                                gammarPosForCore = data_dict["domain{0}".format(domain_num)]["gammarPosForCore"]
                                cxmaxlist = data_dict["domain{0}".format(domain_num)]["cxmaxlist"]
                                cymaxlist = data_dict["domain{0}".format(domain_num)]["cymaxlist"]
                                vr = data_dict["domain{0}".format(domain_num)]['vrPos']

                                # # Append core positions
                                # cxmaxlist.append(cx_max_dict["domain{0}".format(domain_num)][0])
                                # cymaxlist.append(cy_max_dict["domain{0}".format(domain_num)][0])

                                ### Core with Positive Vorticity
                                # Append only if the magnitude of circulation is greater than a threshold
                                gammar_max_ind, gammar_max = fa.find_max(mean_gs)
                                if gammar_max > gamma_thd:
                                    # Time array for Ciruclation
                                    trForGammar.append(f / float(rate))
                                    # Append a maximum circulation value
                                    gammar.append(gammar_max)
                                    gammar_err.append(std_gs[gammar_max_ind])
                                    gammarPosForCore.append(gammar_max)
                                    gammas_for_check.append(gammar_max)  # could be used to decide whether the code should stop calculating circulation


                                    # Calculate ring velocity
                                    counter = counter_dict["domain{0}Pos".format(domain_num)]
                                    if counter % vrtimestep == 0 and len(cxmaxlist) > vrtimestep:
                                        trForVr.append(f / float(rate))
                                        if len(trForVr) > 1:
                                            # Calculate ring velocity
                                            print trForVr
                                            print trForVr[counter/vrtimestep-1], trForVr[counter/vrtimestep-2]
                                            vr.append(compute_dist(cxmaxlist[counter], cymaxlist[counter], cxmaxlist[counter-vrtimestep], cymaxlist[counter-vrtimestep])
                                                      / (trForVr[counter/vrtimestep-1]-trForVr[counter/vrtimestep-2]))
                                            print 'Ring velocity (Pos): %.2f, %d, %d' % (vr[-1], f, domain_num)
                                    # Update counter
                                    counter_dict["domain{0}Pos".format(domain_num)] = counter_dict["domain{0}Pos".format(domain_num)] + 1
                                else:
                                    gammarPosForCore.append(np.nan)


                            if j == 1: # negative vorticity
                                # Refer these lists to lists stored in the data_dict  (NOTICE THAT THEY ARE NOT BEING COPIED!)
                                trForGammar = data_dict["domain{0}".format(domain_num)]["trForGammarNeg"]
                                trForVr = data_dict["domain{0}".format(domain_num)]["trForVrNeg"]
                                trForDr = data_dict["domain{0}".format(domain_num)]['trForDr']
                                gammar = data_dict["domain{0}".format(domain_num)]["gammarNeg"]
                                gammar_err = data_dict["domain{0}".format(domain_num)]["gammarNeg_err"]
                                gammarNegForCore = data_dict["domain{0}".format(domain_num)]["gammarNegForCore"]
                                cxminlist = data_dict["domain{0}".format(domain_num)]["cxminlist"]
                                cyminlist = data_dict["domain{0}".format(domain_num)]["cyminlist"]
                                vr = data_dict["domain{0}".format(domain_num)]['vrNeg']

                                ## Append core positions
                                # cxminlist.append(cx_min_dict["domain{0}".format(domain_num)][0])
                                # cyminlist.append(cy_min_dict["domain{0}".format(domain_num)][0])

                                # Append only if the magnitude of circulation is greater than a threshold
                                gammar_min_ind, gammar_min = fa.find_min(mean_gs)
                                if not gammar_min < -gamma_thd:
                                    gammarNegForCore.append(np.nan)
                                else:
                                    # Time array for circulation
                                    trForGammar.append(f / float(rate))
                                    # Append a minimum circulation value
                                    gammar.append(gammar_min)
                                    gammar_err.append(std_gs[gammar_min_ind])
                                    gammarNegForCore.append(gammar_min)
                                    gammas_for_check.append(gammar_min)  # could be used to decide whether the code should stop calculating circulation
                                    # Calculate ring velocity
                                    counter = counter_dict["domain{0}Neg".format(domain_num)]
                                    if counter % vrtimestep == 0 and len(cxminlist) > vrtimestep:
                                        trForVr.append(f / float(rate))
                                        if len(trForVr) > 1:
                                            # Calculate ring velocity
                                            print 'DEBUGGING!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! '
                                            print domain_num, vorticity_sign[j]
                                            print compute_dist(cxminlist[counter], cyminlist[counter], cxminlist[counter - vrtimestep], cyminlist[counter - vrtimestep])
                                            print trForVr[counter / vrtimestep - 1] , trForVr[counter / vrtimestep - 2]
                                            vr.append(compute_dist(cxminlist[counter], cyminlist[counter], cxminlist[counter - vrtimestep], cyminlist[counter - vrtimestep])
                                                      / (trForVr[counter / vrtimestep - 1] - trForVr[counter / vrtimestep - 2]))
                                            #print 'Ring velocity (Neg): %.2f, %d, %d' % (vr[-1], f, domain_num)
                                            print 'DEBUGGING!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! '
                                    # Update counter
                                    counter_dict["domain{0}Neg".format(domain_num)] = counter_dict["domain{0}Neg".format(domain_num)] + 1

                                    # # Calculate ring diameter
                                    # try:
                                    #     dri = compute_dist(cx_max_dict["domain{0}".format(domain_num)], cy_max_dict["domain{0}".format(domain_num)],
                                    #                       cx_min_dict["domain{0}".format(domain_num)], cy_min_dict["domain{0}".format(domain_num)])
                                    #     # Update diameter and time arrays
                                    #     trForDr.append(f/float(rate))
                                    #     dr.append(dri)
                                    #     print 'Quadrant%d: dr=%.2f' % (domain_num, dri)
                                    #     # print trForDr, dr
                                    #     # print 'Diameter: %.2f, %d, %d' % (dri, f, domain_num)
                                    # except IndexError:
                                    #     print 'One of vortex ring cores was not found. Cannot compute ring diameter for the quadrant %d' % domain_num
                                    #     continue




                    # Now, circulation was computed around detected cores!

                    # Quit computing circulation if...
                        # shortest distance between rings is shorter than a threshold d_thd (default: 25mm)
                        # AND circulation around each core is greater than a threshold gamma_thd (default: 1000mm^2/s)
                # list of distances between counterrotating cores
                ds = [d12, d13, d24, d34]

                gammas_for_check = [x for x in gammas_for_check if x != []]  # remove empty lists
                gammas_for_check = map(abs, gammas_for_check) # make all elements positive


            # Plot time-evolution data ONLY before collision
            if (not args.process_all and any(d < d_thd for d in ds)) or f == frames[-1] or terminate:
                ## Plot distances between counterrotating cores
                print 'Vortex rings are about to collide!! Do not compute circulation for later frames...'
                fig1, ax1 = graph.plot(time, d12_list, fignum=1, subplot=111, label='$d_{12}$')
                fig1, ax1 = graph.plot(time, d13_list, fignum=1, subplot=111, label='$d_{13}$')
                fig1, ax1 = graph.plot(time, d24_list, fignum=1, subplot=111, label='$d_{24}$')
                fig1, ax1 = graph.plot(time, d34_list, fignum=1, subplot=111, label='$d_{34}$')
                graph.labelaxes(ax1, 'time', 'distance between neighbor cores with opposite vorticity')
                graph.setaxes(ax1, np.min(time), np.max(time), 0, imsize[1] * scale)
                plt.legend()
                plt.show()

                marker = ['v', '^', 's', 'o']  # makers corresponding to domains
                fillstyle = ['full', 'none']  # Positive core: fill, Negative core: no fill

                for domain_num in range(1, 5):
                    trForGammarPos = data_dict["domain{0}".format(domain_num)]["trForGammarPos"]
                    trForGammarNeg = data_dict["domain{0}".format(domain_num)]["trForGammarNeg"]
                    trForVrPos = data_dict["domain{0}".format(domain_num)]["trForVrPos"]
                    trForVrNeg = data_dict["domain{0}".format(domain_num)]["trForVrNeg"]
                    trForDr = data_dict["domain{0}".format(domain_num)]['trForDr']
                    gammarPos = data_dict["domain{0}".format(domain_num)]["gammarPos"]
                    gammarPos_err = data_dict["domain{0}".format(domain_num)]["gammarPos_err"]
                    gammarNeg = np.abs(data_dict["domain{0}".format(domain_num)]["gammarNeg"])  # take absolute values of negative circulation values
                    gammarNeg_err = data_dict["domain{0}".format(domain_num)]["gammarNeg_err"]
                    gammarPosForCore = data_dict["domain{0}".format(domain_num)]["gammarPosForCore"]
                    gammarNegForCore = data_dict["domain{0}".format(domain_num)]["gammarNegForCore"]
                    cxmaxlist = data_dict["domain{0}".format(domain_num)]["cxmaxlist"]  # core positions
                    cymaxlist = data_dict["domain{0}".format(domain_num)]["cymaxlist"] # core positions
                    cxminlist = data_dict["domain{0}".format(domain_num)]["cxminlist"] # core positions
                    cyminlist = data_dict["domain{0}".format(domain_num)]["cyminlist"] # core positions
                    vrPos = data_dict["domain{0}".format(domain_num)]['vrPos']
                    vrNeg = data_dict["domain{0}".format(domain_num)]['vrNeg']
                    dr = data_dict["domain{0}".format(domain_num)]['dr']


                    labels = ['top left', 'bottom left', 'top right', 'bottom right']
                    labelsPos = ['top left (+)', 'bottom left (+)', 'top right (+)', 'bottom right (+)']
                    labelsNeg = ['top left (-)', 'bottom left (-)', 'top right (-)', 'bottom right (-)']

                    # Drop the last element b/c trForVr has elements one less than vrPos/Neg
                    trForVrPos, trForVrNeg = trForVrPos[:-1], trForVrNeg[:-1]

                    #print trForGammarPos, gammarPos
                    # Clean data about circulation, ring diameter, ring velocity
                    if not trForGammarPos == []:
                        cxmaxlist, gammarPosForCore, cymaxlist = process.clean_multi_dim_array_trio_using_median(cxmaxlist, gammarPosForCore, cymaxlist, cutoffratio=0.6, mode='less')
                        cxmaxlist, gammarPosForCore, cymaxlist = process.clean_multi_dim_array_trio_using_median(cxmaxlist, gammarPosForCore, cymaxlist, cutoffratio=1.3, mode='greater')

                        trForGammarPos, gammarPos, gammarPos_err = process.clean_multi_dim_array_trio_using_median(trForGammarPos, gammarPos, gammarPos_err, cutoffratio=0.6, mode='less')
                        trForGammarPos, gammarPos, gammarPos_err = process.clean_multi_dim_array_trio_using_median(trForGammarPos, gammarPos, gammarPos_err, cutoffratio=1.3, mode='greater')
                        gammarPos_avg = np.mean(gammarPos)
                        gammarPos_std = np.std(gammarPos)
                    else:
                        gammarPos_avg, gammarPos_std = np.nan, np.nan
                    if not trForGammarNeg == []:
                        cxminlist, gammarNegForCore, cyminlist = process.clean_multi_dim_array_trio_using_median(cxminlist, gammarNegForCore, cyminlist, cutoffratio=0.6, mode='less')
                        cxminlist, gammarNegForCore, cyminlist = process.clean_multi_dim_array_trio_using_median(cxminlist, gammarNegForCore, cyminlist, cutoffratio=1.3, mode='greater')

                        trForGammarNeg, gammarNeg, gammarNeg_err = process.clean_multi_dim_array_trio_using_median(trForGammarNeg, gammarNeg, gammarNeg_err, cutoffratio=0.6, mode='less')
                        trForGammarNeg, gammarNeg, gammarNeg_err = process.clean_multi_dim_array_trio_using_median(trForGammarNeg, gammarNeg, gammarNeg_err, cutoffratio=1.3, mode='greater')
                        gammarNeg_avg = np.mean(gammarNeg)
                        gammarNeg_std = np.std(gammarNeg)
                        gammarNeg_std = np.std(gammarNeg)
                    else:
                        gammarNeg_avg, gammarNeg_std = np.nan, np.nan

                    if not trForVrPos == []:
                        trForVrPos, vrPos = process.clean_multi_dim_array_pair_using_cutoff(trForVrPos, vrPos,
                                                                                            cutoff=1300.,
                                                                                            mode='greater')
                        trForVrPos, vrPos = process.clean_multi_dim_array_pair_using_median(trForVrPos, vrPos,
                                                                                            cutoffratio=0.6,
                                                                                            mode='less')
                        trForVrPos, vrPos = process.clean_multi_dim_array_pair_using_median(trForVrPos, vrPos,
                                                                                            cutoffratio=1.3,
                                                                                            mode='greater')
                        vrPos_avg = np.mean(vrPos)
                        vrPos_std = np.std(vrPos)
                    else:
                        vrPos_avg, vrPos_std = np.nan, np.nan

                    if not trForVrNeg == []:
                        trForVrNeg, vrNeg = process.clean_multi_dim_array_pair_using_cutoff(trForVrNeg, vrNeg,
                                                                                            cutoff=1300.,
                                                                                            mode='greater')
                        trForVrNeg, vrNeg = process.clean_multi_dim_array_pair_using_median(trForVrNeg, vrNeg,
                                                                                            cutoffratio=0.6,
                                                                                            mode='less')
                        trForVrNeg, vrNeg = process.clean_multi_dim_array_pair_using_median(trForVrNeg, vrNeg,
                                                                                            cutoffratio=1.3,
                                                                                            mode='greater')
                        vrNeg_avg = np.mean(vrNeg)
                        vrNeg_std = np.std(vrNeg)
                    else:
                        vrNeg_avg, vrNeg_std = np.nan, np.nan


                    if not trForDr == []:
                        trForDr, dr = process.clean_multi_dim_array_pair_using_cutoff(trForDr, dr, cutoff=10,
                                                                                      mode='less')
                        trForDr, dr = process.clean_multi_dim_array_pair_using_cutoff(trForDr, dr, cutoff=50.,
                                                                                      mode='greater')
                        trForDr, dr = process.clean_multi_dim_array_pair_using_median(trForDr, dr, cutoffratio=0.6,
                                                                                      mode='less')
                        trForDr, dr = process.clean_multi_dim_array_pair_using_median(trForDr, dr, cutoffratio=1.3,
                                                                                      mode='greater')
                        dr_avg = np.mean(dr)
                        dr_std = np.std(dr)

                    else:
                        dr_avg, dr_std = np.nan, np.nan

                    # Plot circulation, ring velocity, and diameter
                    # CIRCULATION PLOT (TIME EVOLUTION)
                    if not trForGammarPos == []:
                        fig8, ax8 = graph.errorbar(trForGammarPos, gammarPos, yerr=gammarPos_err, marker='o',
                                                   color=colors[domain_num - 1], label=labelsPos[domain_num - 1],
                                                   alpha=0.7, fillstyle=fillstyle[0], fignum=2, subplot=131,
                                                   figsize=(20, 5))
                    if not trForGammarNeg == []:
                        fig8, ax8 = graph.errorbar(trForGammarNeg, gammarNeg, yerr=gammarNeg_err, marker='o',
                                                   color=colors[domain_num - 1], label=labelsNeg[domain_num - 1],
                                                   alpha=0.7, fillstyle=fillstyle[1], fignum=2, subplot=131,
                                                   figsize=(20, 5))
                    if not trForGammarPos == [] and not trForGammarNeg == []:
                        graph.labelaxes(ax8, 'Time ($s$)', 'Circulation ($mm^2/s$)')
                        if not math.isnan(max(gammarPos_avg, gammarNeg_avg)):
                            gammar_lim = max([max(gammarPos_avg, gammarNeg_avg) * 1.3,
                                              np.max(np.concatenate((gammarPos, gammarNeg))), gammar_lim])
                            graph.setaxes(ax8, 0, time[-1], 0, gammar_lim)
                            # if not trForGammarPos == []:
                            #     text = 'Average $\Gamma$ (+): %.1f' % gammarPos_avg + '$mm^2/s$'
                            #     graph.addtext(ax8, x=(time[-1])/10., y=gammarPos_avg * 1.3 / 8. * 4., text=text)
                            #     text = 'Std. (+): %.1f' % gammarPos_std + '$mm^2/s$'
                            #     graph.addtext(ax8, x=(time[-1])/10., y=gammarNeg_std * 1.3 / 8. * 3., text=text)
                            # if not trForGammarNeg == []:
                            #     text = 'Average $\Gamma$ (-): %.1f' % gammarNeg_avg + '$mm^2/s$'
                            #     graph.addtext(ax8, x=(time[-1]) / 10., y=gammarNeg_avg * 1.3 / 8. * 2., text=text)
                            #     text = 'Std. (-): %.1f' % gammarNeg_std + '$mm^2/s$'
                            #     graph.addtext(ax8, x=(time[-1]) / 10., y=gammarNeg_std * 1.3 / 8. * 1., text=text)
                    else:
                        fig8, ax8 = graph.set_fig(fignum=2, subplot=131, figsize=(20, 5))
                        graph.labelaxes(ax8, 'Time ($s$)', 'Circulation ($mm^2/s$)')

                    # RING VELOCITY PLOT (TIME EVOLUTION)
                    if not trForVrPos == []:
                        fig9, ax9 = graph.scatter(trForVrPos, vrPos, marker='o', color=colors[domain_num - 1],
                                                  fillstyle=fillstyle[0], label=labelsPos[domain_num - 1],
                                                  alpha=0.7, fignum=2, subplot=132, figsize=(20, 5))
                    if not trForVrNeg == []:
                        fig9, ax9 = graph.scatter(trForVrNeg, vrNeg, marker='o', color=colors[domain_num - 1],
                                                  fillstyle=fillstyle[1], label=labelsNeg[domain_num - 1],
                                                  alpha=0.7, fignum=2, subplot=132, figsize=(20, 5))
                    if not trForVrPos == [] and not trForVrNeg == []:
                        graph.labelaxes(ax9, 'Time ($s$)', 'Ring velocity ($mm/s$)')
                        if not math.isnan(max(vrPos_avg, vrNeg_avg)):
                            vr_lim = max([max(vrPos_avg, vrNeg_avg) * 1.3, np.max((np.concatenate((vrPos, vrNeg)))), vr_lim])
                            graph.setaxes(ax9, 0, time[-1], 0, vr_lim)
                            # Add text (ring velocity and std)
                            # if not trForVrPos == []:
                            #     text = 'Average $v_r$ (+): %.1f' % vrPos_avg + '$mm/s$'
                            #     graph.addtext(ax9, x=(time[-1])/10., y=vrPos_avg * 1.3 / 8. * 4, text=text)
                            #     text = 'Std. (-): %.1f' % vrPos_std + '$mm/s$'
                            #     graph.addtext(ax9, x=(time[-1]) / 10., y=vrPos_std * 1.3 / 8. * 3, text=text)
                            # if not trForVrNeg == []:
                            #     text = 'Average $v_r$ (+): %.1f' % vrNeg_avg + '$mm/s$'
                            #     graph.addtext(ax9, x=(time[-1]) / 10., y=vrNeg_avg * 1.3 / 8 * 2, text=text)
                            #     text = 'Std. (-): %.1f' % vrNeg_std + '$mm/s$'
                            #     graph.addtext(ax9, x=(time[-1]) / 10., y=vrNeg_std * 1.3 / 8. * 1, text=text)
                    else:
                        # If there is no data, make an empty figure
                        fig9, ax9 = graph.set_fig(fignum=2, subplot=132, figsize=(20, 5))
                        graph.labelaxes(ax9, 'Time ($s$)', 'Ring velocity ($mm/s$)')

                    # RING DIAMETER PLOT (TIME-EVOLUTION)
                    # if not trForDr == []: # For some reason, this fails... Use the next line instead- takumi 4/14/18
                    if not len(trForDr) == 0:
                        fig10, ax10 = graph.scatter(trForDr, dr, marker='o', color=colors[domain_num - 1],
                                                    fillstyle=fillstyle[0], label=labels[domain_num - 1],
                                                    alpha=0.7, fignum=2, subplot=133, figsize=(20, 5))
                        graph.labelaxes(ax10, 'Time ($s$)', 'Ring diameter ($mm$)')
                        dr_lim = max(dr_avg * 1.3, np.max(dr), dr_lim)
                        graph.setaxes(ax10, 0, time[-1], 0, 45)
                        # text = 'Average $D$: %.1f' % dr_avg + '$mm$'
                        # graph.addtext(ax10, x=(time[-1])/10., y=dr_avg*1.3/4.*2, text=text)
                        # text = 'Std.: %.1f' % dr_std + '$mm$'
                        # graph.addtext(ax10, x=(time[-1])/10., y=dr_avg * 1.3 / 4., text=text)
                    else:
                        fig10, ax10 = graph.set_fig(fignum=2, subplot=133, figsize=(20, 5))
                        graph.labelaxes(ax10, 'Time ($s$)', 'Ring diameter ($mm$)')
                ax8.legend()
                ax9.legend()
                ax10.legend()

                savedir = resultsdir + '/time_evolution/'
                filename = 'circulation_vring_diameter_before_collision'
                graph.save(savedir + filename, ext='png', close=True)


                ### Plot trajectories
                fig3, ax31 = graph.set_fig(fignum=3, subplot=111, figsize=(16,10))
                for domain_num in range(1, 5):
                    # these are lists of core positions
                    cxmax = data_dict["domain{0}".format(domain_num)]["cxmaxlist"]
                    cymax = data_dict["domain{0}".format(domain_num)]["cymaxlist"]
                    cxmin = data_dict["domain{0}".format(domain_num)]["cxminlist"]
                    cymin = data_dict["domain{0}".format(domain_num)]["cyminlist"]

                    core_positions = [[cxmax, cymax], [cxmin, cymin]]
                    vorticity_sign = ['positive', 'negative']
                    for j, core_position in enumerate(core_positions):
                        print core_position
                        cx, cy = core_position[0], core_position[1]
                        ax31.plot(cx, cy, color=colors[domain_num-1], marker=marker[domain_num-1],
                                      alpha=0.7, fillstyle=fillstyle[j])
                        graph.setaxes(ax31, 0, imsize[1]*scale, 0, imsize[0]*scale)
                        graph.labelaxes(ax31, 'x [mm]', 'y [mm]')
                        ax31.invert_yaxis()

                savedir = resultsdir + '/time_evolution/'
                filename = 'trajectories'
                graph.save(savedir + filename, ext='png', close=True)


                # Save data in json format
                for domain_num in range(1, 5):
                    trForGammarPos = data_dict["domain{0}".format(domain_num)]["trForGammarPos"]
                    trForGammarNeg = data_dict["domain{0}".format(domain_num)]["trForGammarNeg"]
                    trForVrPos = data_dict["domain{0}".format(domain_num)]["trForVrPos"]
                    trForVrNeg = data_dict["domain{0}".format(domain_num)]["trForVrNeg"]
                    trForDr = data_dict["domain{0}".format(domain_num)]['trForDr']
                    trForTrajPos = data_dict["domain{0}".format(domain_num)]['trForTrajPos']
                    trForTrajNeg = data_dict["domain{0}".format(domain_num)]['trForTrajNeg']
                    gammarPos = data_dict["domain{0}".format(domain_num)]["gammarPos"]
                    gammarPos_err = data_dict["domain{0}".format(domain_num)]["gammarPos_err"]
                    gammarNeg = np.abs(data_dict["domain{0}".format(domain_num)][
                                           "gammarNeg"])  # take absolute values of negative circulation values
                    gammarNeg_err = data_dict["domain{0}".format(domain_num)]["gammarNeg_err"]
                    cxmaxlist = data_dict["domain{0}".format(domain_num)]["cxmaxlist"]
                    cymaxlist = data_dict["domain{0}".format(domain_num)]["cymaxlist"]
                    cxminlist = data_dict["domain{0}".format(domain_num)]["cxminlist"]
                    cyminlist = data_dict["domain{0}".format(domain_num)]["cyminlist"]
                    vrPos = data_dict["domain{0}".format(domain_num)]['vrPos']
                    vrNeg = data_dict["domain{0}".format(domain_num)]['vrNeg']
                    dr = data_dict["domain{0}".format(domain_num)]['dr']

                    # Save data in json format
                    time_evolution_data = {'trForGammarPos': trForGammarPos,
                                           'trForGammarNeg': trForGammarNeg,
                                           'trForVrPos': trForVrPos,
                                           'trForVrNeg': trForVrNeg,
                                           'trForDr': trForDr,
                                           'trForTrajPos': trForTrajPos,
                                           'trForTrajNeg': trForTrajNeg,
                                           'gammarPos': gammarPos,
                                           'gammarNeg': gammarNeg.tolist(),
                                           'gammarPos_err': gammarPos_err,
                                           'gammarNeg_err': gammarNeg_err,
                                           'cxmaxlist': cxmaxlist,
                                           'cymaxlist': cymaxlist,
                                           'cxminlist': cxminlist,
                                           'cyminlist': cyminlist,
                                           'vrPos': vrPos,
                                           'vrNeg': vrNeg,
                                           'dr': dr
                                           }

                    time_evolution_data_name = 'time_evolution_data_domain%d_before_collision.json' % domain_num
                    time_evolution_data_path = savedir + time_evolution_data_name
                    # rw.write_json(time_evolution_data_path, time_evolution_data)
                    with open(time_evolution_data_path, 'w') as fyle:
                        json.dump(time_evolution_data, fyle, sort_keys=True, indent=1, separators=(',', ': '))
                        fyle.close()
                print '------------------------------'

                #initialize rx and ry
                rx, ry = 0.5, 0.5
                use_roi = False
                terminate = False
                break

            if not args.process_all and any(d < d_thd for d in ds):
                break


        #
        #
        # # Processed a cine!
        #
        # print '------------------------------'
        #
        # print 'PLOTTING TIME-EVOLUTION'
        # # Convenction for plotting
        # #marker = ['v', '^', 's', 'o'] # makers corresponding to domains
        # fillstyle = ['full', 'none'] #Positive core: fill, Negative core: no fill
        #
        #
        # for domain_num in range(1, 5):
        #     trForGammarPos = data_dict["domain{0}".format(domain_num)]["trForGammarPos"]
        #     trForGammarNeg = data_dict["domain{0}".format(domain_num)]["trForGammarNeg"]
        #     trForVrPos = data_dict["domain{0}".format(domain_num)]["trForVrPos"]
        #     trForVrNeg = data_dict["domain{0}".format(domain_num)]["trForVrNeg"]
        #     trForDr = data_dict["domain{0}".format(domain_num)]['trForDr']
        #     gammarPos = data_dict["domain{0}".format(domain_num)]["gammarPos"]
        #     gammarPos_err = data_dict["domain{0}".format(domain_num)]["gammarPos_err"]
        #     gammarNeg = np.abs(data_dict["domain{0}".format(domain_num)]["gammarNeg"]) # take absolute values of negative circulation values
        #     gammarNeg_err = data_dict["domain{0}".format(domain_num)]["gammarNeg_err"]
        #     cxmaxlist = data_dict["domain{0}".format(domain_num)]["cxmaxlist"]
        #     cymaxlist = data_dict["domain{0}".format(domain_num)]["cymaxlist"]
        #     cxminlist = data_dict["domain{0}".format(domain_num)]["cxminlist"]
        #     cyminlist = data_dict["domain{0}".format(domain_num)]["cyminlist"]
        #     vrPos = data_dict["domain{0}".format(domain_num)]['vrPos']
        #     vrNeg = data_dict["domain{0}".format(domain_num)]['vrNeg']
        #     dr = data_dict["domain{0}".format(domain_num)]['dr']
        #
        #     labels = ['top left', 'bottom left', 'top right', 'bottom right']
        #     labelsPos = ['top left (+)', 'bottom left (+)', 'top right (+)', 'bottom right (+)']
        #     labelsNeg = ['top left (-)', 'bottom left (-)', 'top right (-)', 'bottom right (-)']
        #
        #     # Drop the last element b/c trForVr has elements one less than vrPos/Neg
        #     trForVrPos, trForVrNeg = trForVrPos[:-1], trForVrNeg[:-1]
        #     print trForDr, dr
        #     #Clean data about circulation, ring diameter, ring velocity
        #     if not trForGammarPos ==[]:
        #         # trForGammarPos, gammarPos, gammarPos_err = process.clean_multi_dim_array_trio_using_median(trForGammarPos, gammarPos, gammarPos_err, cutoffratio=0.6, mode='less')
        #         # trForGammarPos, gammarPos, gammarPos_err = process.clean_multi_dim_array_trio_using_median(trForGammarPos, gammarPos, gammarPos_err, cutoffratio=1.3, mode='greater')
        #         gammarPos_avg = np.mean(gammarPos)
        #         gammarPos_std = np.std(gammarPos)
        #     else:
        #         gammarPos_avg, gammarPos_std = np.nan, np.nan
        #     if not trForGammarNeg == []:
        #         # trForGammarNeg, gammarNeg, gammarNeg_err = process.clean_multi_dim_array_trio_using_median(trForGammarNeg, gammarNeg, gammarNeg_err, cutoffratio=0.6, mode='less')
        #         # trForGammarNeg, gammarNeg, gammarNeg_err = process.clean_multi_dim_array_trio_using_median(trForGammarNeg, gammarNeg, gammarNeg_err, cutoffratio=1.3, mode='greater')
        #         gammarNeg_avg = np.mean(gammarNeg)
        #         gammarNeg_std = np.std(gammarNeg)
        #         gammarNeg_std = np.std(gammarNeg)
        #     else:
        #         gammarNeg_avg, gammarNeg_std = np.nan, np.nan
        #     if not trForVrPos == []:
        #         trForVrPos, vrPos = process.clean_multi_dim_array_pair_using_cutoff(trForVrPos, vrPos, cutoff=1300., mode='greater')
        #         trForVrPos, vrPos = process.clean_multi_dim_array_pair_using_median(trForVrPos, vrPos, cutoffratio=0.6, mode='less')
        #         trForVrPos, vrPos = process.clean_multi_dim_array_pair_using_median(trForVrPos, vrPos, cutoffratio=1.3, mode='greater')
        #         vrPos_avg = np.mean(vrPos)
        #         vrPos_std = np.std(vrPos)
        #     else:
        #         vrPos_avg, vrPos_std = np.nan, np.nan
        #     if not trForVrNeg == []:
        #         trForVrNeg, vrNeg = process.clean_multi_dim_array_pair_using_cutoff(trForVrNeg, vrNeg, cutoff=1300., mode='greater')
        #         trForVrNeg, vrNeg = process.clean_multi_dim_array_pair_using_median(trForVrNeg, vrNeg, cutoffratio=0.6, mode='less')
        #         trForVrNeg, vrNeg = process.clean_multi_dim_array_pair_using_median(trForVrNeg, vrNeg, cutoffratio=1.3, mode='greater')
        #         vrNeg_avg = np.mean(vrNeg)
        #         vrNeg_std = np.std(vrNeg)
        #     else:
        #         vrNeg_avg, vrNeg_std = np.nan, np.nan
        #     if not trForDr == []:
        #         trForDr, dr = process.clean_multi_dim_array_pair_using_cutoff(trForDr, dr, cutoff=4., mode='less')
        #         trForDr, dr = process.clean_multi_dim_array_pair_using_cutoff(trForDr, dr, cutoff=50., mode='greater')
        #         trForDr, dr = process.clean_multi_dim_array_pair_using_median(trForDr, dr, cutoffratio=0.6, mode='less')
        #         trForDr, dr = process.clean_multi_dim_array_pair_using_median(trForDr, dr, cutoffratio=1.3, mode='greater')
        #         dr_avg = np.mean(dr)
        #         dr_std = np.std(dr)
        #         print trForDr, dr
        #     else:
        #         dr_avg, dr_std = np.nan, np.nan
        #
        #     # print gammarPos_avg,gammarNeg_avg,vrPos_avg,vrNeg_avg,dr_avg
        #
        #     # gammarPos_avg = np.mean(gammarPos)
        #     # gammarNeg_std = np.std(gammarNeg)
        #     # vrPos_avg = np.mean(vrPos)
        #     # vrPos_std = np.std(vrPos)
        #     # vrNeg_avg = np.mean(vrNeg)
        #     # vrNeg_std = np.std(vrNeg)
        #
        #
        #     # #Error processing in case gammar etc. are empty arrays
        #     # if len(trForGammarPos)==0 or len(trForVrPos)==0 or len(trForDr)==0:
        #     #     fig8 = plt.figure()
        #     #     ax = fig8.add_axes([0, 0, 1, 1])
        #     #     left, width = .25, .5
        #     #     bottom, height = .25, .5
        #     #     right = left + width
        #     #     top = bottom + height
        #     #     ax.text(0.5 * (left + right), 0.5 * (bottom + top), 'No vortex ring was detected!',
        #     #             horizontalalignment='center',
        #     #             verticalalignment='center',
        #     #             fontsize=20, color='red',
        #     #             transform=ax.transAxes)
        #     #     savedir = resultsdir + '/time_evolution/'
        #     #     filename = 'No_vortex_ring_detected'
        #     #     graph.save(savedir + filename, ext='png', close=True)
        #     #     continue
        #
        #     # Plot circulation, ring velocity, and diameter
        #     # CIRCULATION PLOT (TIME EVOLUTION)
        #     if not trForGammarPos == []:
        #         fig8, ax8 = graph.errorbar(trForGammarPos, gammarPos, yerr=gammarPos_err, marker='o', color=colors[domain_num-1], label=labelsPos[domain_num-1],
        #                                    alpha=0.7, fillstyle=fillstyle[0], fignum=2, subplot=131, figsize=(20, 5))
        #     if not trForGammarNeg == []:
        #         fig8, ax8 = graph.errorbar(trForGammarNeg, gammarNeg, yerr=gammarNeg_err, marker='o', color=colors[domain_num-1], label=labelsNeg[domain_num-1],
        #                                    alpha=0.7, fillstyle=fillstyle[1], fignum=2, subplot=131, figsize=(20, 5))
        #     if not trForGammarPos == [] and not trForGammarNeg == []:
        #         graph.labelaxes(ax8, 'Time ($s$)', 'Circulation ($mm^2/s$)')
        #         if not math.isnan(max(gammarPos_avg, gammarNeg_avg)):
        #             gammar_lim = max([max(gammarPos_avg, gammarNeg_avg)*1.3, np.max(np.concatenate((gammarPos, gammarNeg))), gammar_lim])
        #             graph.setaxes(ax8, 0, time[-1], 0, gammar_lim)
        #             # if not trForGammarPos == []:
        #             #     text = 'Average $\Gamma$ (+): %.1f' % gammarPos_avg + '$mm^2/s$'
        #             #     graph.addtext(ax8, x=(time[-1])/10., y=gammarPos_avg * 1.3 / 8. * 4., text=text)
        #             #     text = 'Std. (+): %.1f' % gammarPos_std + '$mm^2/s$'
        #             #     graph.addtext(ax8, x=(time[-1])/10., y=gammarNeg_std * 1.3 / 8. * 3., text=text)
        #             # if not trForGammarNeg == []:
        #             #     text = 'Average $\Gamma$ (-): %.1f' % gammarNeg_avg + '$mm^2/s$'
        #             #     graph.addtext(ax8, x=(time[-1]) / 10., y=gammarNeg_avg * 1.3 / 8. * 2., text=text)
        #             #     text = 'Std. (-): %.1f' % gammarNeg_std + '$mm^2/s$'
        #             #     graph.addtext(ax8, x=(time[-1]) / 10., y=gammarNeg_std * 1.3 / 8. * 1., text=text)
        #     else:
        #         fig8, ax8 = graph.set_fig(fignum=2, subplot=131, figsize=(20, 5))
        #         graph.labelaxes(ax8, 'Time ($s$)', 'Circulation ($mm^2/s$)')
        #
        #
        #     # RING VELOCITY PLOT (TIME EVOLUTION)
        #     if not trForVrPos == []:
        #         fig9, ax9 = graph.scatter(trForVrPos, vrPos,  marker='o', color=colors[domain_num-1],fillstyle=fillstyle[0], label=labelsPos[domain_num-1],
        #                                   alpha=0.7, fignum=2, subplot=132, figsize=(20, 5))
        #     if not trForVrNeg == []:
        #         fig9, ax9 = graph.scatter(trForVrNeg, vrNeg,  marker='o', color=colors[domain_num-1], fillstyle=fillstyle[1], label=labelsNeg[domain_num-1],
        #                                   alpha=0.7, fignum=2, subplot=132, figsize=(20, 5))
        #     if not trForVrPos == [] and not trForVrNeg == []:
        #         graph.labelaxes(ax9, 'Time ($s$)', 'Ring velocity ($mm/s$)')
        #         if not math.isnan(max(vrPos_avg, vrNeg_avg)):
        #             vr_lim = max([max(vrPos_avg, vrNeg_avg)*1.3,  np.max((np.concatenate((vrPos, vrNeg)))), vr_lim])
        #             graph.setaxes(ax9, 0, time[-1], 0, vr_lim)
        #             # Add text (ring velocity and std)
        #             # if not trForVrPos == []:
        #             #     text = 'Average $v_r$ (+): %.1f' % vrPos_avg + '$mm/s$'
        #             #     graph.addtext(ax9, x=(time[-1])/10., y=vrPos_avg * 1.3 / 8. * 4, text=text)
        #             #     text = 'Std. (-): %.1f' % vrPos_std + '$mm/s$'
        #             #     graph.addtext(ax9, x=(time[-1]) / 10., y=vrPos_std * 1.3 / 8. * 3, text=text)
        #             # if not trForVrNeg == []:
        #             #     text = 'Average $v_r$ (+): %.1f' % vrNeg_avg + '$mm/s$'
        #             #     graph.addtext(ax9, x=(time[-1]) / 10., y=vrNeg_avg * 1.3 / 8 * 2, text=text)
        #             #     text = 'Std. (-): %.1f' % vrNeg_std + '$mm/s$'
        #             #     graph.addtext(ax9, x=(time[-1]) / 10., y=vrNeg_std * 1.3 / 8. * 1, text=text)
        #     else:
        #         # If there is no data, make an empty figure
        #         fig9, ax9 = graph.set_fig(fignum=2, subplot=132, figsize=(20, 5))
        #         graph.labelaxes(ax9, 'Time ($s$)', 'Ring velocity ($mm/s$)')
        #
        #     print trForDr, len(trForDr)
        #     #if not trForDr == []: # For some reason, this line fails... WHY? Use the next line instead- takumi 4/14/18
        #     if not len(trForDr) == 0:
        #         fig10, ax10 = graph.scatter(trForDr, dr, marker='o', color=colors[domain_num-1], fillstyle=fillstyle[0], label=labels[domain_num-1],
        #                                     alpha=0.7, fignum=2, subplot=133, figsize=(20, 5))
        #         graph.labelaxes(ax10, 'Time ($s$)', 'Ring diameter ($mm$)')
        #         dr_lim = max(dr_avg*1.3, np.max(dr), dr_lim)
        #         graph.setaxes(ax10, 0, time[-1], 0, dr_lim)
        #         # text = 'Average $D$: %.1f' % dr_avg + '$mm$'
        #         # graph.addtext(ax10, x=(time[-1])/10., y=dr_avg*1.3/4.*2, text=text)
        #         # text = 'Std.: %.1f' % dr_std + '$mm$'
        #         # graph.addtext(ax10, x=(time[-1])/10., y=dr_avg * 1.3 / 4., text=text)
        #     else:
        #         fig10, ax10 = graph.set_fig(fignum=2, subplot=133, figsize=(20, 5))
        #         graph.labelaxes(ax10, 'Time ($s$)', 'Ring diameter ($mm$)')
        # ax8.legend()
        # ax9.legend()
        # ax10.legend()
        #
        # savedir = resultsdir + '/time_evolution/'
        # filename = 'circulation_vring_diameter_all'
        # graph.save(savedir+filename, ext='png', close=True)
        #
        # # Save data in json format
        # for domain_num in range(1, 5):
        #     trForGammarPos = data_dict["domain{0}".format(domain_num)]["trForGammarPos"]
        #     trForGammarNeg = data_dict["domain{0}".format(domain_num)]["trForGammarNeg"]
        #     trForVrPos = data_dict["domain{0}".format(domain_num)]["trForVrPos"]
        #     trForVrNeg = data_dict["domain{0}".format(domain_num)]["trForVrNeg"]
        #     trForDr = data_dict["domain{0}".format(domain_num)]['trForDr']
        #     gammarPos = data_dict["domain{0}".format(domain_num)]["gammarPos"]
        #     gammarPos_err = data_dict["domain{0}".format(domain_num)]["gammarPos_err"]
        #     gammarNeg = np.abs(data_dict["domain{0}".format(domain_num)]["gammarNeg"]) # take absolute values of negative circulation values
        #     gammarNeg_err = data_dict["domain{0}".format(domain_num)]["gammarNeg_err"]
        #     cxmaxlist = data_dict["domain{0}".format(domain_num)]["cxmaxlist"]
        #     cymaxlist = data_dict["domain{0}".format(domain_num)]["cymaxlist"]
        #     cxminlist = data_dict["domain{0}".format(domain_num)]["cxminlist"]
        #     cyminlist = data_dict["domain{0}".format(domain_num)]["cyminlist"]
        #     vrPos = data_dict["domain{0}".format(domain_num)]['vrPos']
        #     vrNeg = data_dict["domain{0}".format(domain_num)]['vrNeg']
        #     dr = data_dict["domain{0}".format(domain_num)]['dr']
        #
        #     # Save data in json format
        #     time_evolution_data = {'trForGammarPos': trForGammarPos,
        #                            'trForGammarNeg': trForGammarNeg,
        #                            'trForVrPos': trForVrPos,
        #                            'trForVrNeg': trForVrNeg,
        #                            'trForDr': trForDr,
        #                            'gammarPos': gammarPos,
        #                            'gammarNeg': gammarNeg.tolist(),
        #                            'gammarPos_err':gammarPos_err,
        #                            'gammarNeg_err': gammarNeg_err,
        #                            'cxmaxlist': cxmaxlist,
        #                            'cymaxlist': cymaxlist,
        #                            'cxminlist': cxminlist,
        #                            'cyminlist': cyminlist,
        #                            'vrPos': vrPos,
        #                            'vrNeg': vrNeg,
        #                            'dr': dr
        #                            }
        #
        #     time_evolution_data_name = 'time_evolution_data_domain%d_all.json' %domain_num
        #     time_evolution_data_path = savedir + time_evolution_data_name
        #     #rw.write_json(time_evolution_data_path, time_evolution_data)
        #     with open(time_evolution_data_path, 'w') as fyle:
        #         json.dump(time_evolution_data, fyle, sort_keys=True, indent=1, separators=(',', ': '))
        #         fyle.close()
        #
        # print '---------------'


    print 'Done'